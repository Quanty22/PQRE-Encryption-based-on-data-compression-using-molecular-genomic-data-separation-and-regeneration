?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app" />
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <!-- UAC manifest parameters
             If you want to change the Windows User Account Control level, replace the node
             requestedExecutionLevel to one of the following.

        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />

            Specifying the requestedExecutionLevel element will disable file and registry virtualization.
            Remove this element if the application requires virtualization for reverse
            compatibility.
        -->
        <requestedExecutionLevel level="asInvoker" uiAccess="false" />
      </requestedPrivileges>
      <applicationRequestMinimum>
        <defaultAssemblyRequest permissionSetReference="Custom" />
        <PermissionSet class="System.Security.PermissionSet" version="1" Unrestricted="true" ID="Custom" SameSite="site" />
      </applicationRequestMinimum>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- List of Windows versions on which this application has been tested
           and it will work. Uncomment the relevant items so that Windows
           automatically selected the most compatible environment. -->
      <!-- Windows Vista -->
      <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->
      <!-- Windows 7 -->
      <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->
      <!-- Windows 8 -->
      <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->
      <!-- Windows 8.1 -->
      <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->
      <!-- Windows 10 -->
      <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->
    </application>
  </compatibility>
  <!-- Indicates that the application supports DPI sensing and will not be automatically scaled by Windows at higher
       DPI values. Windows Presentation Foundation (WPF) applications support DPI detection by default; they do not need to
       specifically include a parameter for this. For Windows Forms applications running on the .NET Framework 4.6 that have this setting set, you must
       Also set "EnableWindowsFormsHighDpiAutoResizing" to "true" in the app.config file.
       
       At the same time, the application begins to take into account long paths. For more information, see https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation.-->
  <!--
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>
  -->
  <!-- Enable themes for common Windows controls and dialog boxes (Windows XP and later) -->
  <!--
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>
  -->
</assembly>



Asseminfo


using System.Reflection;
using System.Runtime.InteropServices;

// General information about this assembly is provided by the following set
// set of attributes. Change the values ​​of these attributes to change the information that
// related to the assembly.
[assembly: AssemblyTitle("NaVeOl_Cripto")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("NaVeOl_Cripto")]
[assembly: AssemblyCopyright("Copyright ©  2023 Eight To Seven | Naveol. ® 8(to)7 A Dutch company Registered IF-Depot IS BOIP Luxembourg:143627A")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to False makes types in this assembly invisible
// for COM components. If you need to access a type in this assembly via
// COM, you should set the ComVisible attribute to TRUE for this type.
[assembly: ComVisible(false)]

// The following GUID serves to identify the type library if this project is to be visible to COM
[assembly: Guid("dd8c982e-8c46-41ae-a33c-870802aefcfd")]

// Assembly version information consists of the following four values:
//
// Major version number
// Additional version number
// Build number
// Editorial
//
// You can set all values ​​or accept the default build and revision numbers
// using "*" as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]


Resource dsign

//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by the program.
// Executable version: 4.0.30319.42000
//
// Changes to this file may cause incorrect operation and will be lost if
// re-generation of code.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NaVeOl_Cripto.Properties {
    using System;
    
    
    /// <summary>
    /// Strongly typed resource class for finding localized strings, etc.
    /// </summary>
    // This class is created automatically by the StronglyTypedResourceBuilder class
    // using a tool such as ResGen or Visual Studio.
    // To add or remove a member, modify the .ResX file and run ResGen again
    // with the /str parameter or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        /// Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("NaVeOl_Cripto.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        /// Overwrites the CurrentUICulture property of the current thread for all
        /// accesses a resource using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}


Resource rex
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>




Design settings

//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by the program.
// Executable version: 4.0.30319.42000
//
// Changes to this file may cause incorrect operation and will be lost if
// re-generation of code.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NaVeOl_Cripto.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "17.5.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool MultiSelct {
            get {
                return ((bool)(this["MultiSelct"]));
            }
            set {
                this["MultiSelct"] = value;
            }
        }
    }
}


Set set

<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)" GeneratedClassNamespace="NaVeOl_Cripto.Properties" GeneratedClassName="Settings">
  <Profiles />
  <Settings>
    <Setting Name="MultiSelct" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
  </Settings>
</SettingsFile>


Crypto


using System;
using System.Security.Cryptography;
using System.IO;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.ComponentModel;
using System.Data;
using System.Threading.Tasks;




namespace QuickMixCounter
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }
        

        //A_In: Array of Word; A_Out: Array of byte;
        //was
        //A, B, C, E:Array of byte;  //dAta FFot Mat  SWich
        //lenfile:integer;
        //i:integer;
        //j,n:integer;
        //U:cardinal;
        //d:byte ;
        //C0,C1,Count:integer;
        //FName:string;
        //tempS:string;
        
        public static byte ReadN(long Ui, byte L, byte[] B)
        {
            // procedure for reading a return number with length L bits
            // from array B[ ] from position Ui
            // Mandatory either dynamic array or index 0..n
            long i, k;
            byte ms; byte D;
            int wd;

            if (!(0 < L && L < 8)) { MessageBox.Show("Error: readN L is no range"); }; // exit if the data length is incorrect
            Ui--; // convert position to bit index
            k = Ui / 8; // calculate the byte index in the array
            i = Ui / 7; // number of shifts
                                     // get the most significant bits
            if ((i + L) > 8) { wd = B[k + 1] * 256; } else { wd = 0; };
            wd |= B[k]; // combine two bytes
            D = (byte)(wd >> (byte)i); // shift the number
                                           // forming a mask based on data length
            ms = 0;
            for (i = 1; i < (L + 1); i++) { ms = (byte)(ms + ms + 1); }
            return (byte)(D&ms); // masking extra bits
        }        
        public static void AppendN( byte D, byte L, int Ui, byte[] B )
        {
            // procedure for adding a number D of length L bits
            // into array "B" from position U bits
        int k=0; int i;
        byte ms=0;
        int wd;

        if (!(0 < L && L < 8))
            { MessageBox.Show("Error: readN L is no range"); } // exit if the data length is incorrect
        for (i = 1; i < (L + 1); i++) { ms = (byte)(ms + ms + 1); };

        D = (byte)(D&ms); // masking extra bits
        i= Ui & 7; // number of shifts
        wd = D;
            wd <<= i; // get shifted data
            Ui += L;
        k= ((Ui-1) / 8) + 1; // calculate the new length of the array
            Array.Resize<byte>(ref B, k + 1); // setting the length of the array, counting from 0!
            if (i + L > 8) {
                i = B.Length - 1;
                // adding a number to the array
                B[i] = (byte)(B[i] | (0xFF & ((byte)(wd >> 8))));
                B[i - 1] = (byte)(B[i - 1] | ((byte)(0xFF & (byte)wd)));
            } else
            {
                i = B.Length - 1;
                // adding a number to the array
                B[i] = (byte)(B[i] | (byte)(0xFF & (byte)(wd)));
            }
        }



        private void Button1_Click(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open as Data File"))) 
            using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save as Reduced Data File"))) 
            using (FileStream fs2 = File.OpenWrite(MCDE.SaveDialog("Save DNA Data File"))) 
            
            { 
            byte[] b = new byte[8];
            head A;
            byte c;
            int readLen;
            int i = 0;
            while ((readLen = fs.Read(b, 0, 8)) > 0)
                {
                A = System.BitConverter.ToUInt64(b, 0);
                    /*Here is a block of XOR and ROR64 */
                    ulong v = MCDE.TransposeBitMatrix(A);
                    /*Here is a block of XOR and ROR64 */
                    A = v;
                b = System.BitConverter.GetBytes(A);
                fs1.Write(b, 0, 7); // In one stream of information
                    c = b[7];
                fs2.WriteByte(c); // to another DNA stream
                }
            }
            MessageBox.Show("OK");
        }
        private void Button2_Click(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open as Reduced Data File")))
            using (FileStream fs1 = File.OpenRead(MCDE.OpenDialog("Open as DNA Data File")))
            using (FileStream fs2 = File.OpenWrite(MCDE.SaveDialog("Save as Data File")))
            {
                byte[] b = new byte[8];           
                head A;
                byte c;
                int readLen;             
                int i = 0;
                while ((readLen = fs.Read(b, 0, 7)) > 0) // read Reduced Data 7 bytes
                {
                    c = (byte)fs1.ReadByte();// read DNA Data 1 byte
                    b[7] = c;
                    A = System.BitConverter.ToUInt64(b, 0);
                    /*Here is a block of XOR and ROR64 */
                    ulong v = MCDE.TransposeBitMatrix(A);
                    /*Here is a block of XOR and ROR64 */
                    A = v;
                    b = System.BitConverter.GetBytes(A);
                    fs2.Write(b, 0, 8); // Recovered data
                    
                }
            }
            MessageBox.Show("OK");

        }

        private void Button3_Click(object sender, EventArgs e)
        {
            
            //uint w=Convert.ToUInt32(textBox1.Text);
            //w=MCDE.ROR32(w, 1);
            //textBox1.Text = Convert.ToString(w);


        }

        private void button10_Click(object sender, EventArgs e)
        {
            // Read file 1 as a sequence of matrices
            //string s1 = MCDE.OpenDialog();
            //string s2 = MCDE.SaveDialog();
            //string s3 = MCDE.SaveDialog();
//using (var reader = new BinaryReader(File.Open(s1, FileMode.Open)))
            {
                //Loop through each 8 bytes in the file 
                //for (int i = 0; i < reader.BaseStream.Length; i += 8)
                //{
                //    //Create an array to store the 8 bytes of a matrix 
                //    byte[] b = new byte[8];

                //    //Read the next 8 bytes from the file into the array  
                //    for (int j = 0; j < b.Length; j++)
                //        b[j] = reader.ReadByte();

                //    //Perform a transpose of each matrix  
                //    //TransposeMatrix(b);

                    



                //    //Save first 4 bytes of each matrix to file 2                     
                //    using (var writer2 = new BinaryWriter(File.Open(s2, FileMode.Append))) { writer2.Write(b, 0, 1); }

                //    //Save remaining 4 bytes of each matrix to file 3                 
                //    using (var writer3 = new BinaryWriter(File.Open(s3, FileMode.Append))) { writer3.Write(b, 1, 7); }
                //}
            }

            //Function to perform transpose on an 8x8 bit matrix stored in an array of bytes b[8]   private static void TransposeMatrix(byte[] b)  {      byte temp;           for (int i=0;i<4;i++)      {           int k=7-i;           temp=b[i];           b[i]=b[k];           b[k]=temp;       }}
        }

        private void button4_Click(object sender, EventArgs e)
        {
            string s = MCDE.OpenDialog("Open Data File");
            string s1 = MCDE.SaveDialog("Save Cript Data File");
            byte[] b = new byte[512];
            int i = 0;
            do
            { 
                b = MCDE.ReadBlockFromFile(s, i*512, 512);
                MCDE.MixByteArr512(b); // you can give 2 keys
                                  //MCDE.UnMixByteArr512(b);//you can give 2 keys
                MCDE.WriteBlockToFile(s1, b, i*512, 512);
                i++;
            }
            while (b.Length == 512);
            MessageBox.Show("OK");
        }

        private void button3_Click_1(object sender, EventArgs e)
        {

            string s = MCDE.OpenDialog("Open Data File");
            string s1 = MCDE.SaveDialog("Save Cript Data File");
            byte[] b = new byte[512];
            int i = 0;
            do
            {
                b = MCDE.ReadBlockFromFile(s, i * 512, 512);
                
                MCDE.MixByteArr512(b); // you can give 2 keys
                                      //MCDE.UnMixByteArr512(b);//you can give 2 keys
                MCDE.WriteBlockToFile(s1, b, i * 512, 512);
                i++;
            }
            while (b.Length == 512);
            MessageBox.Show("OK");

        }

        private void button11_Click(object sender, EventArgs e)
        {
            
        }

        private void button12_Click(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open    File")))

            using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save   File")))
            {
                byte[] b = new byte[1];
                head A;
                byte c;
                int readLen;
                int i = 0;
                while ((readLen = fs.Read(b, 0, 1)) > 0) // read Reduced Data 7 bytes
                {
                    b[0] ^= (byte)(MCDE.RndConst(314159265, 9874, 3));
                    fs1.Write(b, 0, 1); // Recovered data

                }
            }
            MessageBox.Show("OK");
        }

        private void button11_Click_1(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open    File")))

            using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save   File")))
            {
                byte[] b = new byte[1];
                head A;
                byte c;
                int readLen;
                int i = 0;
                while ((readLen = fs.Read(b, 0, 1)) > 0) // read Reduced Data 7 bytes
                {
                    i--;
                    b[0] ^= (byte)(MCDE.RndConst((uint)(314159265 + b[0]+i), (uint)(9874+i), 3));
                    fs1.Write(b, 0, 1); // Recovered data

                }
            }
            MessageBox.Show("OK");
            
        }
    }
    
}

// Array.Reverse(people, 1, 3);
//uint[] uints = new uint[Mb.Length];
//string s = Convert.ToString(Fost);
//MessageBox.Show(s);


Appconf

<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <configSections>
        <sectionGroup name="userSettings" type="System.Configuration.UserSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" >
            <section name="NaVeOl_Cripto.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false" />
        </sectionGroup>
    </configSections>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
    <userSettings>
        <NaVeOl_Cripto.Properties.Settings>
            <setting name="MultiSelct" serializeAs="String">
                <value>True</value>
            </setting>
        </NaVeOl_Cripto.Properties.Settings>
    </userSettings>
</configuration>



Form1

using System;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq; 
using System.Threading;
using System.Windows.Forms;
using static NaVeOl_Cripto.MCDE;

namespace NaVeOl_Cripto
{
    public partial class Form1 : Form
    {
        private readonly CancellationTokenSource cancellationTokenSource;// для Threading progressBar 
        public Form1()
        {
            InitializeComponent();
            this.Height = 121;
            this.Width = 320;
            InitializeDataTable(dataTable);

            // check (ID ?) exit
            if (!System.IO.File.Exists("id.ini")) // // Error file-id is missing
            { Application.Exit(); };
            if (!System.IO.File.Exists("serial.ini")) // // Error file-serial is missing
            { Application.Exit(); };

            // id does not match
            if (!Verify.SN_ID_DemoChecker()) { Application.Exit(); };
            // check (LS ?) demo
            MCDE.GlobalVariable.demoVer = !Verify.LS_SN_RealizeChecker();
            if (MCDE.GlobalVariable.demoVer)
            { this.Text = "NaVeOl Eco - demo version"; }
            else { this.Text = "NaVeOl Eco Professional"; }
            /// cancellationTokenSource = new CancellationTokenSource();// для Threading progressBar 



        }
        bytes percent;
        public bool TrEnableKey = false;
        public byte[] Key5 = new byte[512];
        public byte[] StatKey5 = new byte[512];
        //public byte[] VarKey5 = new byte[512];
        public byte[] Data = new byte[512];
        public byte[] Buff = new byte[512];
        public byte[] Hash = new byte[16];
        public byte[] HashKey = new byte[512];
        public static long percentMax = 0;//***
        public long percentValue = 0;

        // Create a Stopwatch timer object
        Stopwatch stopwatch = new Stopwatch();

        #region Click the buttons Green Red Yellow Gray Blue
        private void pictureBox1_Click(object sender, EventArgs e)
        {
            Cursor.Current = Cursors.WaitCursor;            
            GetAllFilesFromMultiselect();
            stopwatch.Start();

            for (int i = 0; i < stringListFile.Length; i++)
            // sorting through all the elements  stringListFile - full path
            //porn elements correspond to them stringListFileDistant -relative path
            { EcoIn(i); }            
            stopwatch.Stop();
            // Cleaned and updated the "explorer"
            // just cleared the table and lists and selected
            clear_TableListFiles_Selected();
            dataTable.Clear();
            dataGridView1.DataSource = FillDataTable(GlobalVariable.currentDirectory, dataTable);
            Cursor.Current = Cursors.Default;
            MessageBox.Show("Time is: " + Convert.ToString(stopwatch.Elapsed));
            stopwatch.Reset();
        } 
        private void pictureBox2_Click(object sender, EventArgs e)
        {
            Cursor.Current = Cursors.WaitCursor;
            GetAllFilesFromMultiselect();
            stopwatch.Start();
            for (int i = 0; i < stringListFile.Length; i++)
            { Eco_Out(i); }
            stopwatch.Stop();

            // Cleared and updated the "explorer"
            // just cleared the table and lists and selected
            clear_TableListFiles_Selected();
            dataTable.Clear();
            dataGridView1.DataSource = FillDataTable(GlobalVariable.currentDirectory, dataTable);          
            Cursor.Current = Cursors.Default;           
            MessageBox.Show("Time is: " + Convert.ToString(stopwatch.Elapsed));
            stopwatch.Reset();
        } 
        private void pictureBox3_Click(object sender, EventArgs e)
        {
            HideShowKeyForm();
            dataGridView1.Visible = false;
        } 
        private void pictureBox5_Click(object sender, EventArgs e)
        {
            MessageBox.Show("NaVeOl Eco is a system data encoding method that uses the \"8(to)7\" " +
                "technology. This method is designed to protect confidential information from unauthorized " +
                "access and ensure data security.\r\n\r\nTo use NaVeOl coding , specify the configuration of " +
                "the algorithm: with a Coordinates, with a Coordinates file. Enter the Coordinates (at least 8 characters) " +
                "and any key file. Just specify the encoding file you want to encode in the system. " +
                "The system will then use \"8(to)7\" technology to encode the data, making it unreadable " +
                "for those who do not have a proper decoding key and a key file.\r\n\r\n" +
                "To decoding  the encoded data, you will need to use the same NaVeOl Eco system and enter " +
                "the encoded data along with the decoding key and the key file (optional). " +
                "Then the system will decoding  the data and make it readable again.\r\n\r\n" +
                "It is important to keep the decoding key and the key file safe and share it only " +
                "with authorized persons who need access to the encoded data. This will help ensure " +
                "the security and confidentiality of your confidential information.\r\n\r\n" +
                "In general, NaVeOl Eco is the latest, reliable and effective method of encoding and " +
                "protecting confidential data.", "Information about NaVeOl Eco");
        } 
        private void pictureBox4_Click(object sender, EventArgs e)
        {
            FormConfig frm2 = new FormConfig();
            frm2.ShowDialog(); // Launch Form2
        }
        #endregion

        #region Interface   
        #region Click on the additional buttons    
        
        private void pictureBox7_Click(object sender, EventArgs e)
        {
            textBox2.Text = MCDE.Files.OpenDialog("Load Key File");
        }

        private void pictureBox8_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog folderBrowserDialog = new FolderBrowserDialog();

            if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
            {
                string selectedPath = folderBrowserDialog.SelectedPath;
                ////Moving to the designated directory ***********
                //update the current directory
                GlobalVariable.currentDirectory = selectedPath;                
                dataTable.Clear();
                //// load catalog
                dataGridView1.DataSource = FillDataTable(selectedPath, dataTable);
            }
        }

        private void pictureBox9_Click(object sender, EventArgs e)
        {
            TrEnableKey = CheckFillingKeyForm();
            if (TrEnableKey)  // unvisible
            {
                HideShowKeyForm();
                this.Height = 341;
                this.Width = 422;
                dataGridView1.Visible = true;
                pictureBox8.Visible = true;
                label5.Visible = true;
                dataGridView1.DataSource = FillDataTable("C:\\", dataTable);
                #region Table setup
                dataGridView1.Columns[0].HeaderText = "";
                dataGridView1.Columns[0].Width = 30;
                dataGridView1.Columns[1].Width = 150;
                dataGridView1.Columns[2].Visible = false;
                dataGridView1.Columns[3].Width = dataGridView1.Width -
                    dataGridView1.Columns[0].Width - dataGridView1.Columns[1].Width - 20;
                dataGridView1.Columns[4].Visible = false;
                dataGridView1.Columns[5].Visible = false;
                dataGridView1.Columns[6].Visible = false;

                #endregion

            }
        }
        #endregion

        #region Move Buttons   

        private void pictureBox1_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox1.Image = Resource1.a2;
        }

        private void pictureBox1_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox1.Image = Resource1.a1;
        }


        private void pictureBox2_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox2.Image = Resource1.b2;
        }

        private void pictureBox2_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox2.Image = Resource1.b1;
        }

        private void pictureBox3_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox3.Image = Resource1.c2;
        }

        private void pictureBox3_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox3.Image = Resource1.c1;
        }

        private void pictureBox4_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox4.Image = Resource1.d2;
        }

        private void pictureBox4_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox4.Image = Resource1.d1;
        }

        private void pictureBox5_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox5.Image = Resource1.e2;
        }

        private void pictureBox5_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox5.Image = Resource1.e1;
        }


        private void pictureBox6_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox6.Image = Resource1.g2;
            textBox1.PasswordChar = '\0';
        }

        private void pictureBox6_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox6.Image = Resource1.g1;
            textBox1.PasswordChar = '*';
        }


        private void pictureBox7_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox7.Image = Resource1.h2;
        }

        private void pictureBox7_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox7.Image = Resource1.h1;
        }

        private void pictureBox9_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox9.Image = Resource1.f2;
        }

        private void pictureBox9_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox9.Image = Resource1.f1;
        }

        private void pictureBox1_MouseEnter(object sender, EventArgs e)
        {
            pictureBox1.Top = pictureBox1.Top - 3;
        }

        private void pictureBox1_MouseLeave(object sender, EventArgs e)
        {
            pictureBox1.Top = pictureBox1.Top + 3;
        }

        private void pictureBox2_MouseEnter(object sender, EventArgs e)
        {
            pictureBox2.Top = pictureBox2.Top - 3;
        }

        private void pictureBox2_MouseLeave(object sender, EventArgs e)
        {
            pictureBox2.Top = pictureBox2.Top + 3;
        }

        private void pictureBox3_DragEnter(object sender, DragEventArgs e)
        {

        }

        private void pictureBox3_MouseEnter(object sender, EventArgs e)
        {
            pictureBox3.Top = pictureBox3.Top - 3;
        }

        private void pictureBox3_DragLeave(object sender, EventArgs e)
        {

        }

        private void pictureBox3_MouseLeave(object sender, EventArgs e)
        {
            pictureBox3.Top = pictureBox3.Top + 3;
        }

        private void pictureBox4_MouseEnter(object sender, EventArgs e)
        {
            pictureBox4.Top = pictureBox4.Top - 3;
        }

        private void pictureBox4_MouseLeave(object sender, EventArgs e)
        {
            pictureBox4.Top = pictureBox4.Top + 3;
        }

        private void pictureBox5_MouseEnter(object sender, EventArgs e)
        {
            pictureBox5.Top = pictureBox5.Top - 3;
        }

        private void pictureBox5_MouseLeave(object sender, EventArgs e)
        {
            pictureBox5.Top = pictureBox5.Top + 3;
        }
        #endregion
        #endregion

        private void toolStripMenuItem2_Click(object sender, EventArgs e)
        {

        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {
            label1.Text = "PassWord " +
                Convert.ToString(textBox1.Text.Length) + " characters";
        }

        private void button2_Click(object sender, EventArgs e) // *** 
        {
            TrEnableKey = CheckFillingKeyForm();
            if (TrEnableKey)  // unvisible
            {
                HideShowKeyForm();
                this.Height = 341;
                this.Width = 422;
                dataGridView1.Visible = true;
                pictureBox8.Visible = true;
                dataGridView1.DataSource = FillDataTable("C:\\", dataTable);
                #region Setting up a table  
                dataGridView1.Columns[0].HeaderText = "";
                dataGridView1.Columns[0].Width = 30;
                dataGridView1.Columns[1].Width = 150;
                dataGridView1.Columns[2].Visible = false;
                dataGridView1.Columns[3].Width = dataGridView1.Width -
                    dataGridView1.Columns[0].Width - dataGridView1.Columns[1].Width - 20;
                dataGridView1.Columns[4].Visible = false;
                dataGridView1.Columns[5].Visible = false;
                dataGridView1.Columns[6].Visible = false;
                #endregion

            }
        }


        #region Menu connection with buttons
        private void encodeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            pictureBox1_Click(null, null);
        }

        private void decodeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            pictureBox2_Click(null, null);
        }

        private void keyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            pictureBox3_Click(null, null);
        }
        private void configurationToolStripMenuItem_Click(object sender, EventArgs e)
        {
            pictureBox4_Click(null, null);
        }

        private void helpToolStripMenuItem_Click(object sender, EventArgs e)
        {
            pictureBox5_Click(null, null);
        }
        #endregion


        private void listView1_SelectedIndexChanged(object sender, EventArgs e)
        {

        }
        /// <summary>
        /// Checking the filling in of the password form fields 
        /// and check for errors
        /// </summary>
        private bool CheckFillingKeyForm()
        {
            //Check that all fields are filled in correctly
            bool trig = true;
            if (textBox1.Text.Length < 8)// The error is less than 8 characters in the password
            {
                trig = false;
                MessageBox.Show("You must enter a password of at least 8 characters");
            }
            if (textBox2.Text.Length == 0)//The error is 0 characters in the password
            {
                trig = false;
                MessageBox.Show("You must enter address a password file");
            }
            if (!System.IO.File.Exists(textBox2.Text)) // The error file is empty
            {
                trig = false;
                MessageBox.Show("Error password file address");
            }
            return trig;
        }
        /// <summary>
        /// Turns the password file into a 512 Buff key
        /// </summary>
        private void Key512FromFilePwd()
        {
            using (FileStream fs = System.IO.File.OpenRead(textBox2.Text))//the key file was turned into a key array Buff
            {
                for (int i = 0; i < 512; i++) { Buff[i] = 0; };//Cleared

                while (fs.Read(Data, 0, 512) > 0)// we read in blocks of 512 bytes to the end of the file
                {
                    for (int i = 0; i < 512; i++) { Buff[i] += Data[i]; };//Put all the arrays into one
                }


            }// ++ Buff
        }
        /// <summary>
        ///All passwords are User, file, ID, and in the future, S/N are converted into one key per 512
        /// </summary>
        private void ConsolidationToKey5()
        {
            // !!! Here all keys are static !!! ***
            // finding the HASH of the key file
            Hash = Files.FileToMD5(textBox2.Text);//received a HASH of 32 bytes++ 
            HashKey = MCDE.Keys.StrechArray_byte512(Hash);// let's stretch the HASH to 512 bytes ++

            Key512FromFilePwd();// Turning the Key file into a Buff[] 512 bytes
            for (int i = 0; i < 512; i++) { HashKey[i] ^= Buff[i]; } // ++let's put a Buff on the HashKey

            // .. finding the static key
            StatKey5 = Randomize.RndConst1(HashKey[78], 512);// 
            //////}
            // We stretch the password to a large key
            Key5 = MCDE.Keys.Pas_strechToArray512(textBox1.Text);
            // We knock everything into one array
            for (int i = 0; i < 512; i++)
            {
                Key5[i] = (byte)(Key5[i] ^ StatKey5[i] + (HashKey[i] + 1));
            }
            ////Explanation of key operations:
            ////    Hash->HashKey(Buff)->HashKey
            ////    file->Buff
            //// StatKey5
            ////    PassWord->Key5
            ////    Key5(StatKey5, HashKey)->Key5
        }
        /// <summary>
        /// Checking the form completion 
        /// and based on user-entered data 
        /// /// creating the key KEY5
        /// </summary>
        private void CheckFormAndMakeKey5()
        {
            TrEnableKey = CheckFillingKeyForm(); // checking the form completion
                                                 //TrEnableKey = trig; // Send to the Global Variable
                                                 // result of filling out the form
            if (TrEnableKey)//If the form is filled out correctly
            {
                ConsolidationToKey5(); //We collect the Password, password file, ID and create a Key(512) from it
            }
        }

        private void HideShowKeyForm()
        {
            label1.Visible = !label1.Visible;
            label2.Visible = !label2.Visible;
            label3.Visible = !label3.Visible;

            textBox1.Visible = !textBox1.Visible;
            textBox2.Visible = !textBox2.Visible;
            pictureBox6.Visible = !pictureBox6.Visible;

            pictureBox7.Visible = !pictureBox7.Visible;
            pictureBox9.Visible = !pictureBox9.Visible;
            statusStrip1.Visible = !statusStrip1.Visible;
            this.Height = 252;
            this.Width = 412;
        }

        private void HideKeyForm()
        {
            label1.Visible = false;
            label2.Visible = false;
            label3.Visible = false;
            textBox1.Visible = false;
            textBox2.Visible = false;
            pictureBox6.Visible = false;

            pictureBox7.Visible = false;
            pictureBox9.Visible = false;
        }

        private void button3_Click(object sender, EventArgs e)
        {

        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            label4.Text = Convert.ToString(stringListFile.Length) + "select files";
        }



        #region Files Selecter
        static readonly DataTable dataTable = new System.Data.DataTable();
        string[] stringList = new string[0];
        string[] stringListDistant = new string[0];
        string[] stringListFile = new string[0];
        string[] stringListFileDistant = new string[0];
        string[] stringListDir = new string[0];

        void InitializeDataTable(DataTable dataTable)
        {
            dataTable.Columns.Add("Ico", typeof(Image));
            dataTable.Columns.Add("Name");
            dataTable.Columns.Add("Ext");
            dataTable.Columns.Add("Path");
            dataTable.Columns.Add("Type");
            dataTable.Columns.Add("Number");
            dataTable.Columns.Add("Sort");

        }
        DataTable FillDataTable(string path, DataTable dataTable)
        {
            pictureBox1.Image = Resource1.a2;
            Image image1 = Resource1.DImg;
            Image image2 = Resource1.FImg;

            string folderPath = path;
            DirectoryInfo directory = new DirectoryInfo(folderPath);

            // Getting a list of folders from a folder
            System.IO.DirectoryInfo[] dirs = directory.GetDirectories();

            // Filling the DataTable with file data
            foreach (DirectoryInfo file in dirs)
            {
                dataTable.Rows.Add(image1, file.Name, file.Extension, file.FullName, "D");
            }

            // Getting a list of files from a folder
            FileInfo[] files = directory.GetFiles();

            // Filling the DataTable with file data
            foreach (FileInfo file in files)
            {
                dataTable.Rows.Add(image2, file.Name, file.Extension, file.FullName, "F");
            }

            
            return dataTable;
        }// 
        void SelectToStringList()
        {
            DataGridViewSelectedRowCollection selectedRows = dataGridView1.SelectedRows;
            // The user has selected rows, we will iterate over each of them
            foreach (DataGridViewRow row in selectedRows)
            {
                // In each row, select a cell in the desired column
                string column1Value = row.Cells["Name"].Value.ToString();
                // We will add the data to the string array
                Array.Resize(ref stringList, stringList.Length + 1);
                stringList[stringList.Length - 1] = column1Value;
            }
        }

        void GetAllFilesFromDir(string path)
        {
            // Get all files in the directory and its subdirectories

            string[] files;
            try
            {
                files = Directory.GetFiles(path, "*", SearchOption.AllDirectories);
            }
            catch (UnauthorizedAccessException ex)
            {
                MessageBox.Show("Unauthorized Access !" + Convert.ToString(ex), "Exception");
                goto Label1;
            }
            // Print the full path of each file
            foreach (string file0 in files)
            {   // we write the source files in one list
                Array.Resize(ref stringListFile, stringListFile.Length + 1);
                stringListFile[stringListFile.Length - 1] = file0;

                // take a relative path and put it in the final list

                // Find the index of the first occurrence of the substring
                string subString = GlobalVariable.currentDirectory;
                int index = file0.IndexOf(subString);
                string file1;
                if (index >= 0)
                { // Deleting the substring - got a relative path
                    file1 = file0.Remove(index, GlobalVariable.currentDirectory.Length);
                    // Written to the final list
                    Array.Resize(ref stringListFileDistant, stringListFileDistant.Length + 1);
                    stringListFileDistant[stringListFileDistant.Length - 1] = file1;
                }
            }
        Label1:;
        }
        //All files from the directory and its subdirectories 
        //moved to a string array

        void GetOnlySelectionDirectories()
        {
            // Assuming the data source for dataGridView1 is a DataTable called "dataTable"
            DataTable dataTable = (DataTable)dataGridView1.DataSource;

            // Iterate over the selected rows
            foreach (DataGridViewRow selectedRow in dataGridView1.SelectedRows)
            {
                // Get the corresponding DataRow from the DataTable
                DataRow dataRow = ((DataRowView)selectedRow.DataBoundItem).Row;

                // Access the value of the "Type" column
                string typeValue = dataRow["Type"].ToString();

                // Check if the value is "D"
                if (typeValue == "D")
                {
                    // Access other column values if needed
                    string column1Value = dataRow["Path"].ToString();

                    Array.Resize(ref stringListDir, stringListDir.Length + 1);
                    stringListDir[stringListDir.Length - 1] = column1Value;
                }
            }
        }
        //Only directories were moved from the selected one to the string array

        void GetOnlySelectionFiles()
        {
            // Assuming the data source for dataGridView1 is a DataTable called "dataTable"
            DataTable dataTable = (DataTable)dataGridView1.DataSource;

            // Iterate over the selected rows
            foreach (DataGridViewRow selectedRow in dataGridView1.SelectedRows)
            {
                // Get the corresponding DataRow from the DataTable
                DataRow dataRow = ((DataRowView)selectedRow.DataBoundItem).Row;

                // Access the value of the "Type" column
                string typeValue = dataRow["Type"].ToString();

                // Check if the value is "D"
                if (typeValue == "F")
                {
                    //Take the original full path
                    string column1Value = dataRow["Path"].ToString();
                    //We take the final relative path
                    string column1ValueDist = dataRow["Name"].ToString();
                    // we put it in the original list
                    Array.Resize(ref stringListFile, stringListFile.Length + 1);
                    stringListFile[stringListFile.Length - 1] = column1Value;
                    //we put it in the final list
                    Array.Resize(ref stringListFileDistant, stringListFileDistant.Length + 1);
                    stringListFileDistant[stringListFileDistant.Length - 1] = column1ValueDist;


                }
            }
        }
        //Only Files were moved from the selected one to the string array
        void GetAllFilesFromMultiselect()
        {
            GetOnlySelectionFiles(); // Took the selected files from the root
            GetOnlySelectionDirectories();//Took the selected directories
            foreach (string str in stringListDir)
            {
                GetAllFilesFromDir(str);
            }

        }

        #endregion     

        private void EcoIn(int index /* stringListFile & stringListFileDistant*/)
        {
            //EnCript(); 
            CheckFormAndMakeKey5();
            if (TrEnableKey)
            {
                HideKeyForm();
                //Find the full addresses of the source and 2 destination files
                bool B = true;
                long FSize;
                string s = stringListFile[index]; /// SOURCE file, relative path
                if (s == "") { B = false; };

                // cut file ******
                // and replace the directory with the remote one
                string s1 = GlobalVariable.directoryEco + stringListFileDistant[index] + ".nvl";
                s1 = s1.Replace("\\\\", "\\");
                if (B)
                {
                    FSize = Files.FileResize(s); // add tail + 512 bytes = rnd + sizeSourceFile)
                                                // Open two files for reading and writing

                    using (FileStream fs = System.IO.File.OpenRead(s))
                    { // if there is no ECO directory, create
                        if (!Directory.Exists(GlobalVariable.directoryEco))
                        {
                            Directory.CreateDirectory(GlobalVariable.directoryEco);
                        }
                        // if there is no directory for the final file in the ecosystem, create
                        string directoryOfDistantFile = Path.GetDirectoryName(s1);
                        if (!Directory.Exists(directoryOfDistantFile))
                        {
                            Directory.CreateDirectory(directoryOfDistantFile);
                        }
                        System.IO.File.Delete(s1);
                        using (FileStream fs1 = System.IO.File.OpenWrite(s1))
                        {

                            #region Variables Encode
                            byte[] b = new byte[256]; // block for microcoding
                            head i = 0;//****
                            int EOF; // 1 - read // 0 - end of file
                            byte[] K = new byte[512];//key
                            byte[] R = new byte[512];//ключ
                            //byte[] MAT1 = new byte[128];
                            //byte[] MAT2 = new byte[128];
                            byte[] MAT = new byte[256];
                            //MAT1 = NaVeOl.GenMat7bit(Key5[i++]);
                            //MAT2 = NaVeOl.GenMat7bit(Key5[MAT1[i++]]);
                            int x = Key5[Key5[0]] + Key5[Key5[5]] * Key5[Key5[8]];
                            MAT = NaVeOl.GenMat8bit(x & 726);
                            i = (ulong)x; // scrolling the key will not start from the beginning
                                          //further FAST! encode without the last block
                                          //read eight 8 bytes (64 bit matrix)

                            #endregion // Declaring variables
                            // the block is created in MCDE.Files.FileResize and the tail is added first
                            // and secretly inserts the length of the source file
                            R = GlobalVariable.EndRndBlock;
                            for (int k = 0; k < Key5.Length; k++)// Incremented index and two keys
                            {
                                Key5[k] = (byte)(Key5[k] ^ R[k]);
                            }
                            percentMax = fs.Length;

                            // Main load: CORE encoding
                            while ((EOF = fs.Read(b, 0, 256)) > 0) // read 256 bytes except the End block
                            {
                                /// percentValue = fs.Position; /// remove

                                /// And in return we leave
                                if ((fs.Position & 33554432) == 33554432)
                                {
                                    progressBar1.Value = (byte)(100.0 / (percentMax) * (fs.Position + 1.0));
                                }

                                Key5[11] = (byte)(Key5[111] ^ NaVeOl.Lower()); // the slowdown of the program from the version could not be reduced further

                                #region key change every Coding block
                                // change the key every block
                                //Stopwatch stopwatch = new Stopwatch();
                                //stopwatch.Start();
                                if ((i & 1) == 0)
                                {//4.5E-9s/Mb
                                    Key5 = NaVeOl.FreshQQKey(Key5, MAT, (int)i & 428);
                                }
                                else
                                { // 6E-9 s/Mb
                                    MAT = NaVeOl.FreshQMAT(MAT, Key5[i & 511]);
                                }


                                // When decoding, a reversal of MAT index<>Number is added
                                // and change the name to MAT1i, MAT2i, MATi
                                #endregion

                                // Self-encryption 4.5E-9 s/Mb
                                for (int j = 0; j < 256; j++)//****
                                {
                                    b[j] = (byte)(b[j] ^ Key5[j]); //+ add a random number

                                };                //1

                                // Swap 7 bits between pairs
                                // Inverse function with MATi
                                //   b = NaVeOl.Encoding_IQ(b, MAT);               //3
                                b = NaVeOl.Encoding_IQ2(b, MAT); // 6E-9 s/Mb  0.04 c / 6.775 Мб

                                //  b = NaVeOl.Encoding_I(b, MAT2, MAT1);                                                      //99
                                //  b = NaVeOl.Encoding_II(b, MAT);                    //5

                                fs1.Write(b, 0, 256); // In one stream 6E-9 s/Mb


                                i++; //increase the key array counter by +1
                            }
                            fs1.Write(R, 0, 512); // In thread RND key
                            progressBar1.Value = 0;
                        }

                    }
                    /// Crop the file to its original size ***** !!!!
                    /// Restoring. Increased at the beginning: Files.FileResize(s)
                    using (FileStream fsSource = new FileStream(s, FileMode.Open))
                    {
                        fsSource.SetLength(GlobalVariable.SizeSourceFile);// cm size!!!
                    }

                }
                else
                {
                    ///-MessageBox.Show("You need select files!");
                }
                //-this.Text = "NaVeOl ECO - demo version   ";
                //-MessageBox.Show("Operation is done", "information");
            }
            else
            {
                MessageBox.Show("Press Yellow coordinates and fill out the form ");
            }

        }
        private void Eco_Out(int index /* stringListFile & stringListFileDistant*/)
        {
            //If the keys are full:
            CheckFormAndMakeKey5();
            if (TrEnableKey)
            {
                HideKeyForm();
                //Find the full addresses of 2 source and destination files
                bool B = true;
#pragma warning disable CS0168 // Variable is declared, but not used
                long FSize;
#pragma warning restore CS0168 // Variable is declared, but not used
                string s1, ext;
                string s = stringListFile[index];// incoming file full address for further modification
                s1 = s;// incoming file full address EVERYTHING!!!!
                if (s == "") { B = false; }; // not empty path
                ext = Path.GetExtension(s); // took the extension
                if (ext != ".nvl") { B = false; };// check the extension of File 1
                s = Path.ChangeExtension(s, null); // discarded File 1 extension
                string pathOut = GlobalVariable.directoryEcoOut;
                // need to discard the current directory

                // take a relative path and add it to the final list

                // Find the index of the first occurrence of the substring
                string subString = GlobalVariable.currentDirectory + "\\";
                int indx = s.IndexOf(subString);
                string file1 = "";
                if (indx >= 0)
                { // Remove the substring - we got a relative path
                    file1 = s.Remove(indx, subString.Length);

                }


                //                                                                           
                s = pathOut + Path.GetDirectoryName(file1) + "\\" + Path.GetFileName(file1);//got the name of the final file That's it!!!!
                s = s.Replace("\\\\", "\\");
                if (TrEnableKey)
                {
                    if (B)
                    {
                        // Read Random Key from the last 512 Decoding block
                        using (FileStream fs1 = System.IO.File.OpenRead(s1))
                        {
                            byte[] buffer = new byte[512]; // 512 bytes of data 
                            FileStream fs = new FileStream(s1, FileMode.Open, FileAccess.Read); // Open file for reading 
                            fs.Seek(-512, SeekOrigin.End); // Go to the end of the file and back 512 bytes 
                            fs.Read(buffer, 0, 512); // Read 512 bytes into buffer 
                            fs.Close();
                            GlobalVariable.EndRndBlock = buffer;
                        }


                        //Pulling out the file length from the last block
                        byte[] m = new byte[8];
                        for (int i = 0; i < 8; i++)
                        //for the inverse function - rearrange A=B^C <-> B=A^C
                        {
                            m[i] = (byte)(GlobalVariable.EndRndBlock[i * i + 7]
                                         ^ GlobalVariable.EndRndBlock[i + 87]);
                        };// and decrypt

                        #region Can be simplified
                        GlobalVariable.SizeSourceFile = BitConverter.ToInt64(m, 0);
                        // SIZE from nvl file to global variable
                        long Fsize = GlobalVariable.SizeSourceFile;
                        #endregion

                        // Open two files 1 for reading and 1 for writing
                        using (FileStream fs1 = System.IO.File.OpenRead(s1)) // nvl
                        { // if there is no directory for the final file from the ecosystem, create
                            if (!Directory.Exists(GlobalVariable.directoryEcoOut))
                            {
                                Directory.CreateDirectory(GlobalVariable.directoryEcoOut);
                            }
                            // if there is no directory for the final file from the ecosystem, create
                            string directoryOfDistantFile = Path.GetDirectoryName(s);
                            if (!Directory.Exists(directoryOfDistantFile))
                            {
                                Directory.CreateDirectory(directoryOfDistantFile);
                            }


                            using (FileStream fs = System.IO.File.OpenWrite(s))  // Decoding recoverable file
                            {
                                #region Decode Variables
                                byte[] b = new byte[256]; // block for microcoding
                                ulong i = 0;//key counter
                                int EOF; // 1 - read // 0 - end of file
                                byte[] K = new byte[512];//key
                                byte[] R = new byte[512];//ключ
                                                         //byte[] MAT1 = new byte[128];
                                                         //byte[] MAT2 = new byte[128];
                                byte[] MAT = new byte[256];
                                //byte[] MAT1i = new byte[128];
                                //byte[] MAT2i = new byte[128];
                                byte[] MATi = new byte[256];

                                //MAT1 = NaVeOl.GenMat7bit(Key5[i++]);
                                //MAT2 = NaVeOl.GenMat7bit(Key5[MAT1[i++]]);
                                int x = Key5[Key5[0]] + Key5[Key5[5]] * Key5[Key5[8]];
                                MAT = NaVeOl.GenMat8bit(x & 726);
                                i = (ulong)x; // scrolling the key will not start from the beginning
                                              // When decoding, a reversal of MAT index<>Number is added
                                              // and change the name to MAT1i, MAT2i, MATi
                                              //MAT1i = NaVeOl.MatTableReplaceIndx2Num(MAT1);
                                              //MAT2i = NaVeOl.MatTableReplaceIndx2Num(MAT2);
                                MATi = NaVeOl.MatTableReplaceIndx2Num(MAT);
                                #endregion

                                //further FAST! decode without the last block
                                //read eight 8 bytes (64 bit matrix)


                                R = GlobalVariable.EndRndBlock;
                                for (int k = 0; k < Key5.Length; k++)// Increment index and two keys
                                { Key5[k] = (byte)(Key5[k] ^ R[k]); }

                                // Resize is needed here - can be moved from the bottom
                                percentMax = fs1.Length;
                                // Main load: Decoding CORE
                                while ((EOF = fs1.Read(b, 0, 256)) > 0) // read 256 bytes except the End block
                                {
                                    // read 1 byte except for the End block EOF on DNA will end, and 512 bytes will remain on RNA Random Key
                                    // now the microcoding block is full
                                    #region Change the key every decoding block
                                    //Change the key every block
                                    Key5[11] = (byte)(Key5[111] ^ 222); // program slowdown depending on version

                                    if ((i & 1) == 0)
                                    {
                                        Key5 = NaVeOl.FreshQQKey(Key5, MAT, (int)i & 428);
                                    }
                                    else
                                    {
                                        MAT = NaVeOl.FreshQMAT(MAT, Key5[i & 511]);
                                        MATi = NaVeOl.MatTableReplaceIndx2Num(MAT);
                                    }

                                    #endregion
                                    percentValue = fs1.Position;
                                    // /// And in return we leave
                                    if ((fs.Position & 33554432) == 33554432)
                                    {
                                        progressBar1.Value = (byte)(100.0 / (percentMax) * (fs.Position + 1.0));
                                    }



                                    b = NaVeOl.Decoding_IQ2(b, MATi);

                                    //  b = NaVeOl.Encoding_IQ(b, MAT);               //3



                                    // Decryption itself at the end
                                    for (int j = 0; j < 256; j++)
                                    {
                                        b[j] = (byte)(b[j] ^ Key5[j]);
                                    };                 //1

                                    fs.Write(b, 0, 256); // Write to a file
                                    i++; //key array counter

                                }
                            }
                        }
                        /// Crop the file to its original size ***** !!!!
                        using (FileStream fsSource = new FileStream(s, FileMode.Open))
                        {
                            fsSource.SetLength(GlobalVariable.SizeSourceFile);// cm size!!!
                        }


                    }
                    else
                    {
                        //  MessageBox.Show("You need select files!");
                    }
                    //this.Text = "NaVeOl ECO - demo version   ";
                    //MessageBox.Show("Operation is done", "information");
                }
                else
                {
                    //  MessageBox.Show("Press Yellow coordinates and fill out the form ");
                }
            }
            progressBar1.Value = 0;


        }






        private void timerDemo_Tick(object sender, EventArgs e)
        {
            if (MCDE.GlobalVariable.demoVer)
            {
                timerDemo.Enabled = false;
                //MessageBox.Show("You are run the demo version.", "Attention!");
                DateTime now = DateTime.Now;
                int YearNow = now.Year;
                int MonsNow = now.Month;
                if ((YearNow > 2024) & (MonsNow > 11))
                {

                    MessageBox.Show("The application's running time is over. " +
                        "The program will be closed.", "Demo version is over");
                    Close();
                };
            }
        }

        private void dataGridView1_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {

        }

        private void dataGridView1_DoubleClick(object sender, EventArgs e)
        {

        }

        private void dataGridView1_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
        {
            //// All this bullshit
            ////To double-click to go to the directory
            ///

            object cellValue = dataGridView1.Rows[e.RowIndex].Cells[4].Value;
            // Cast the value to the desired type
            string value = cellValue.ToString();
            if ((cellValue != null) && (value == "D")) // not empty and not a directory?
            { // take the path
                cellValue = dataGridView1.Rows[e.RowIndex].Cells[3].Value;
                // Cast the value to the desired type
                value = cellValue.ToString();
                // updated the current directory
                GlobalVariable.currentDirectory = value;


Form of

namespace NaVeOl_Cripto
{
    partial class Form1
    {
        /// <summary>
        /// Required constructor variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Release all used resources.
        /// </summary>
        /// <param name="disposing">true if the managed resource should be removed; otherwise false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Code automatically generated by the Windows Form Builder

        /// <summary>
        /// Required method to support the constructor - do not change
        /// the contents of this method using the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Form1));
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.encodeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.decodeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.keyToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.configurationToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.helpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.label1 = new System.Windows.Forms.Label();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.timer1 = new System.Windows.Forms.Timer(this.components);
            this.dataGridView1 = new System.Windows.Forms.DataGridView();
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.filesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.clearToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.timerDemo = new System.Windows.Forms.Timer(this.components);
            this.statusStrip1 = new System.Windows.Forms.StatusStrip();
            this.label4 = new System.Windows.Forms.Label();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            this.pictureBox9 = new System.Windows.Forms.PictureBox();
            this.pictureBox8 = new System.Windows.Forms.PictureBox();
            this.pictureBox7 = new System.Windows.Forms.PictureBox();
            this.pictureBox6 = new System.Windows.Forms.PictureBox();
            this.pictureBox5 = new System.Windows.Forms.PictureBox();
            this.pictureBox4 = new System.Windows.Forms.PictureBox();
            this.pictureBox3 = new System.Windows.Forms.PictureBox();
            this.pictureBox2 = new System.Windows.Forms.PictureBox();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.label5 = new System.Windows.Forms.Label();
            this.menuStrip1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView1)).BeginInit();
            this.contextMenuStrip1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox9)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox8)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox7)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox6)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox5)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox4)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.SuspendLayout();
            // 
            // menuStrip1
            // 
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.encodeToolStripMenuItem,
            this.decodeToolStripMenuItem,
            this.keyToolStripMenuItem,
            this.configurationToolStripMenuItem,
            this.helpToolStripMenuItem});
            this.menuStrip1.LayoutStyle = System.Windows.Forms.ToolStripLayoutStyle.HorizontalStackWithOverflow;
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(406, 24);
            this.menuStrip1.TabIndex = 5;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // encodeToolStripMenuItem
            // 
            this.encodeToolStripMenuItem.Name = "encodeToolStripMenuItem";
            this.encodeToolStripMenuItem.Size = new System.Drawing.Size(53, 20);
            this.encodeToolStripMenuItem.Text = "&In_eco";
            this.encodeToolStripMenuItem.Click += new System.EventHandler(this.encodeToolStripMenuItem_Click);
            // 
            // decodeToolStripMenuItem
            // 
            this.decodeToolStripMenuItem.Name = "decodeToolStripMenuItem";
            this.decodeToolStripMenuItem.Size = new System.Drawing.Size(63, 20);
            this.decodeToolStripMenuItem.Text = "&Out_eco";
            this.decodeToolStripMenuItem.Click += new System.EventHandler(this.decodeToolStripMenuItem_Click);
            // 
            // keyToolStripMenuItem
            // 
            this.keyToolStripMenuItem.Name = "keyToolStripMenuItem";
            this.keyToolStripMenuItem.Size = new System.Drawing.Size(60, 20);
            this.keyToolStripMenuItem.Text = "&Coord\'s";
            this.keyToolStripMenuItem.Click += new System.EventHandler(this.keyToolStripMenuItem_Click);
            // 
            // configurationToolStripMenuItem
            // 
            this.configurationToolStripMenuItem.Name = "configurationToolStripMenuItem";
            this.configurationToolStripMenuItem.Size = new System.Drawing.Size(61, 20);
            this.configurationToolStripMenuItem.Text = "&Config  ";
            this.configurationToolStripMenuItem.Click += new System.EventHandler(this.configurationToolStripMenuItem_Click);
            // 
            // helpToolStripMenuItem
            // 
            this.helpToolStripMenuItem.Name = "helpToolStripMenuItem";
            this.helpToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
            this.helpToolStripMenuItem.Text = "&Help";
            this.helpToolStripMenuItem.Click += new System.EventHandler(this.helpToolStripMenuItem_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(12, 110);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(63, 13);
            this.label1.TabIndex = 6;
            this.label1.Text = "Coordinates";
            this.label1.Visible = false;
            // 
            // textBox1
            // 
            this.textBox1.ForeColor = System.Drawing.Color.Black;
            this.textBox1.Location = new System.Drawing.Point(174, 107);
            this.textBox1.Name = "textBox1";
            this.textBox1.PasswordChar = '*';
            this.textBox1.Size = new System.Drawing.Size(178, 20);
            this.textBox1.TabIndex = 7;
            this.textBox1.Visible = false;
            this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(12, 142);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(114, 13);
            this.label2.TabIndex = 9;
            this.label2.Text = "Select coordinates File";
            this.label2.Visible = false;
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(174, 135);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(178, 20);
            this.textBox2.TabIndex = 10;
            this.textBox2.Visible = false;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(15, 84);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(110, 13);
            this.label3.TabIndex = 13;
            this.label3.Text = "Please fill out the form";
            this.label3.Visible = false;
            // 
            // hours1
            // 
            this.timer1.Enabled = true;
            this.timer1.Interval = 500;
            this.timer1.Tick += new System.EventHandler(this.timer1_Tick);
            // 
            // dataGridView1
            // 
            this.dataGridView1.AllowUserToAddRows = false;
            this.dataGridView1.AllowUserToDeleteRows = false;
            this.dataGridView1.AllowUserToResizeRows = false;
            this.dataGridView1.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
            this.dataGridView1.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dataGridView1.ContextMenuStrip = this.contextMenuStrip1;
            this.dataGridView1.Location = new System.Drawing.Point(0, 85);
            this.dataGridView1.Margin = new System.Windows.Forms.Padding(1, 5, 1, 1);
            this.dataGridView1.Name = "dataGridView1";
            this.dataGridView1.ReadOnly = true;
            this.dataGridView1.RowHeadersVisible = false;
            this.dataGridView1.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.dataGridView1.Size = new System.Drawing.Size(406, 198);
            this.dataGridView1.TabIndex = 16;
            this.dataGridView1.Visible = false;
            this.dataGridView1.CellContentClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellContentClick);
            this.dataGridView1.CellDoubleClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellDoubleClick);
            this.dataGridView1.ColumnWidthChanged += new System.Windows.Forms.DataGridViewColumnEventHandler(this.dataGridView1_ColumnWidthChanged);
            this.dataGridView1.DoubleClick += new System.EventHandler(this.dataGridView1_DoubleClick);
            // 
            // contextMenuStrip1
            // 
            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.filesToolStripMenuItem,
            this.clearToolStripMenuItem});
            this.contextMenuStrip1.Name = "contextMenuStrip1";
            this.contextMenuStrip1.Size = new System.Drawing.Size(159, 48);
            this.contextMenuStrip1.Opening += new System.ComponentModel.CancelEventHandler(this.contextMenuStrip1_Opening);
            // 
            // filesToolStripMenuItem
            // 
            this.filesToolStripMenuItem.Name = "filesToolStripMenuItem";
            this.filesToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.filesToolStripMenuItem.Text = "+add to list files";
            this.filesToolStripMenuItem.Click += new System.EventHandler(this.filesToolStripMenuItem_Click);
            // 
            // clearToolStripMenuItem
            // 
            this.clearToolStripMenuItem.Name = "clearToolStripMenuItem";
            this.clearToolStripMenuItem.Size = new System.Drawing.Size(158, 22);
            this.clearToolStripMenuItem.Text = "- clear list files";
            this.clearToolStripMenuItem.Click += new System.EventHandler(this.clearToolStripMenuItem_Click);
            // 
            // timerDemo
            // 
            this.timerDemo.Enabled = true;
            this.timerDemo.Tick += new System.EventHandler(this.timerDemo_Tick);
            // 
            // statusStrip1
            // 
            this.statusStrip1.Location = new System.Drawing.Point(0, 280);
            this.statusStrip1.Name = "statusStrip1";
            this.statusStrip1.Size = new System.Drawing.Size(406, 22);
            this.statusStrip1.TabIndex = 21;
            this.statusStrip1.Text = "statusStrip1";
            this.statusStrip1.Visible = false;
            this.statusStrip1.ItemClicked += new System.Windows.Forms.ToolStripItemClickedEventHandler(this.statusStrip1_ItemClicked);
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(6, 284);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(10, 13);
            this.label4.TabIndex = 22;
            this.label4.Text = " ";
            // 
            // progressBar1
            // 
            this.progressBar1.Location = new System.Drawing.Point(118, 285);
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(288, 12);
            this.progressBar1.TabIndex = 23;
            this.progressBar1.Click += new System.EventHandler(this.progressBar1_Click);
            // 
            // pictureBox9
            // 
            this.pictureBox9.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox9.Image")));
            this.pictureBox9.Location = new System.Drawing.Point(229, 160);
            this.pictureBox9.Name = "pictureBox9";
            this.pictureBox9.Size = new System.Drawing.Size(76, 27);
            this.pictureBox9.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.pictureBox9.TabIndex = 20;
            this.pictureBox9.TabStop = false;
            this.pictureBox9.Visible = false;
            this.pictureBox9.Click += new System.EventHandler(this.pictureBox9_Click);
            // 
            // pictureBox8
            // 
            this.pictureBox8.Image = global::NaVeOl_Cripto.Resource1.DImg;
            this.pictureBox8.Location = new System.Drawing.Point(361, 42);
            this.pictureBox8.Name = "pictureBox8";
            this.pictureBox8.Size = new System.Drawing.Size(33, 35);
            this.pictureBox8.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox8.TabIndex = 19;
            this.pictureBox8.TabStop = false;
            this.pictureBox8.Visible = false;
            this.pictureBox8.Click += new System.EventHandler(this.pictureBox8_Click);
            // 
            // pictureBox7
            // 
            this.pictureBox7.Image = global::NaVeOl_Cripto.Resource1.h1;
            this.pictureBox7.Location = new System.Drawing.Point(368, 135);
            this.pictureBox7.Name = "pictureBox7";
            this.pictureBox7.Size = new System.Drawing.Size(24, 24);
            this.pictureBox7.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox7.TabIndex = 18;
            this.pictureBox7.TabStop = false;
            this.pictureBox7.Visible = false;
            this.pictureBox7.Click += new System.EventHandler(this.pictureBox7_Click);
            this.pictureBox7.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox7_MouseDown);
            this.pictureBox7.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox7_MouseUp);
            // 
            // pictureBox6
            // 
            this.pictureBox6.Image = global::NaVeOl_Cripto.Resource1.g1;
            this.pictureBox6.Location = new System.Drawing.Point(368, 103);
            this.pictureBox6.Name = "pictureBox6";
            this.pictureBox6.Size = new System.Drawing.Size(24, 24);
            this.pictureBox6.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox6.TabIndex = 17;
            this.pictureBox6.TabStop = false;
            this.pictureBox6.Visible = false;
            this.pictureBox6.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox6_MouseDown);
            this.pictureBox6.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox6_MouseUp);
            // 
            // pictureBox5
            // 
            this.pictureBox5.Image = global::NaVeOl_Cripto.Resource1.e1;
            this.pictureBox5.Location = new System.Drawing.Point(240, 27);
            this.pictureBox5.Name = "pictureBox5";
            this.pictureBox5.Size = new System.Drawing.Size(50, 50);
            this.pictureBox5.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.pictureBox5.TabIndex = 4;
            this.pictureBox5.TabStop = false;
            this.pictureBox5.Click += new System.EventHandler(this.pictureBox5_Click);
            this.pictureBox5.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox5_MouseDown);
            this.pictureBox5.MouseEnter += new System.EventHandler(this.pictureBox5_MouseEnter);
            this.pictureBox5.MouseLeave += new System.EventHandler(this.pictureBox5_MouseLeave);
            this.pictureBox5.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox5_MouseUp);
            // 
            // pictureBox4
            // 
            this.pictureBox4.Image = global::NaVeOl_Cripto.Resource1.d1;
            this.pictureBox4.Location = new System.Drawing.Point(184, 27);
            this.pictureBox4.Name = "pictureBox4";
            this.pictureBox4.Size = new System.Drawing.Size(50, 50);
            this.pictureBox4.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.pictureBox4.TabIndex = 0;
            this.pictureBox4.TabStop = false;
            this.pictureBox4.Click += new System.EventHandler(this.pictureBox4_Click);
            this.pictureBox4.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox4_MouseDown);
            this.pictureBox4.MouseEnter += new System.EventHandler(this.pictureBox4_MouseEnter);
            this.pictureBox4.MouseLeave += new System.EventHandler(this.pictureBox4_MouseLeave);
            this.pictureBox4.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox4_MouseUp);
            // 
            // pictureBox3
            // 
            this.pictureBox3.Image = global::NaVeOl_Cripto.Resource1.c1;
            this.pictureBox3.Location = new System.Drawing.Point(126, 27);
            this.pictureBox3.Name = "pictureBox3";
            this.pictureBox3.Size = new System.Drawing.Size(50, 50);
            this.pictureBox3.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.pictureBox3.TabIndex = 2;
            this.pictureBox3.TabStop = false;
            this.pictureBox3.Click += new System.EventHandler(this.pictureBox3_Click);
            this.pictureBox3.DragEnter += new System.Windows.Forms.DragEventHandler(this.pictureBox3_DragEnter);
            this.pictureBox3.DragLeave += new System.EventHandler(this.pictureBox3_DragLeave);
            this.pictureBox3.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox3_MouseDown);
            this.pictureBox3.MouseEnter += new System.EventHandler(this.pictureBox3_MouseEnter);
            this.pictureBox3.MouseLeave += new System.EventHandler(this.pictureBox3_MouseLeave);
            this.pictureBox3.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox3_MouseUp);
            // 
            // pictureBox2
            // 
            this.pictureBox2.Image = global::NaVeOl_Cripto.Resource1.b1;
            this.pictureBox2.Location = new System.Drawing.Point(65, 27);
            this.pictureBox2.Name = "pictureBox2";
            this.pictureBox2.Size = new System.Drawing.Size(50, 50);
            this.pictureBox2.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.pictureBox2.TabIndex = 1;
            this.pictureBox2.TabStop = false;
            this.pictureBox2.Click += new System.EventHandler(this.pictureBox2_Click);
            this.pictureBox2.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox2_MouseDown);
            this.pictureBox2.MouseEnter += new System.EventHandler(this.pictureBox2_MouseEnter);
            this.pictureBox2.MouseLeave += new System.EventHandler(this.pictureBox2_MouseLeave);
            this.pictureBox2.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox2_MouseUp);
            // 
            // pictureBox1
            // 
            this.pictureBox1.Image = global::NaVeOl_Cripto.Resource1.a1;
            this.pictureBox1.Location = new System.Drawing.Point(6, 27);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(50, 50);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.pictureBox1.TabIndex = 0;
            this.pictureBox1.TabStop = false;
            this.pictureBox1.Click += new System.EventHandler(this.pictureBox1_Click);
            this.pictureBox1.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox1_MouseDown);
            this.pictureBox1.MouseEnter += new System.EventHandler(this.pictureBox1_MouseEnter);
            this.pictureBox1.MouseLeave += new System.EventHandler(this.pictureBox1_MouseLeave);
            this.pictureBox1.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox1_MouseUp);
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.ForeColor = System.Drawing.Color.Black;
            this.label5.Location = new System.Drawing.Point(330, 27);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(76, 13);
            this.label5.TabIndex = 24;
            this.label5.Text = "Change Folder";
            this.label5.Visible = false;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(406, 302);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.progressBar1);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.statusStrip1);
            this.Controls.Add(this.pictureBox8);
            this.Controls.Add(this.pictureBox7);
            this.Controls.Add(this.pictureBox6);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.textBox2);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.pictureBox5);
            this.Controls.Add(this.pictureBox4);
            this.Controls.Add(this.pictureBox3);
            this.Controls.Add(this.pictureBox2);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.menuStrip1);
            this.Controls.Add(this.pictureBox9);
            this.Controls.Add(this.dataGridView1);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MainMenuStrip = this.menuStrip1;
            this.Name = "Form1";
            this.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Naveol Eco- zero user license";
            this.Resize += new System.EventHandler(this.Form1_Resize);
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dataGridView1)).EndInit();
            this.contextMenuStrip1.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox9)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox8)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox7)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox6)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox5)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox4)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.PictureBox pictureBox1;
        private System.Windows.Forms.PictureBox pictureBox2;
        private System.Windows.Forms.PictureBox pictureBox3;
        private System.Windows.Forms.PictureBox pictureBox4;
        private System.Windows.Forms.PictureBox pictureBox5;
        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem encodeToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem decodeToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem keyToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem configurationToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;


resX MS
xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>7, 10</value>
  </metadata>
  <metadata name="timer1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>122, 10</value>
  </metadata>
  <metadata name="contextMenuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>322, 10</value>
  </metadata>
  <metadata name="timerDemo.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>209, 10</value>
  </metadata>
  <metadata name="statusStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>477, 10</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="pictureBox9.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
        FtD9DydXKYSe0vnkAAAAAElFTkSuQmCC
</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>35</value>
  </metadata>
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAEAICAQAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAgAIAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//
        AAD///8ATExMTExMTMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM
        zMzMzMzMzM/8zMzMzMzMzMzMzMzMzMz//MzMzMzMzMzMzMzMzMzP/8zMzMzMz/jMzMzMzMzM//zMzMzM
        zH//jMzMzMzMj//MzMzMzMyP//fMzMzMzP//jMzMzMzP////jMzMzMj///+MzMzM//+I//jMzMyP/4j/
        jMzMzP/4zI//zMzI//zI/4zMzMz//MzI//zMj//MzP+MzMzM//zMzM//iP/8zMz/jMzMzP/8zMzM///4
        zMzM/4zMzMz//MzMzI///MzMzP+MzMzM//zMzMyP//zMzMz/jMzMzP/8zMzM///4zMzM/4zMzMz//MzM
        yP///4zMzP/8zMzM//zMzM//iP/8zMz//MzMzP/8zMz/+MyP/8zM//zMzMz//MzI/4zMyP/MzP/8zMzM
        //jM//jMzMyP/Mj/jMzMzHj///+MzMzMyP//+MzMzMzMj///zMzMzMz//4zMzMzMzH//jMzMzMzMzMzM
        zMzMzMzP+MzMzMzMzMzMzMzMzMzM//zMzMzMzMzMzMzMzMzMz//MzMzMzMzMzMzMzMzMzM/8zMzMzMzM
        zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMxMTExMTExMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
</value>
  </data>
</root>

Form2x
using System;
using System.IO;
using System.Windows.Forms;

namespace NaVeOl_Cripto
{
    public partial class FormConfig : Form
    {
        public FormConfig()
        {
            InitializeComponent();
            textBox1.Text = MCDE.GlobalVariable.directoryEco;
            textBox2.Text = MCDE.GlobalVariable.directoryEcoOut;
        }


        private void checkBox1_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void label1_Click(object sender, EventArgs e)
        {

        }

        private void button1_Click(object sender, EventArgs e)
        {
            Close();            
        }

        private void pictureBox1_Click(object sender, EventArgs e)
        {
            if (Directory.Exists(textBox1.Text))
            {
                MCDE.GlobalVariable.directoryEco = textBox1.Text;

            }

            if (Directory.Exists(textBox2.Text))
            {
                MCDE.GlobalVariable.directoryEcoOut = textBox2.Text;
            }
            Close();
        }

        private void pictureBox2_Click(object sender, EventArgs e)
        // select distention directory for ECO system
        {
            FolderBrowserDialog folderBrowserDialog = new FolderBrowserDialog();
            folderBrowserDialog.Description = "Select directory of ECO";
            folderBrowserDialog.ShowNewFolderButton = true;
            if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
            {
                textBox1.Text = folderBrowserDialog.SelectedPath + "\\";
                MCDE.GlobalVariable.directoryEco = folderBrowserDialog.SelectedPath + "\\";
            }
        }

        
        private void pictureBox2_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox2.Image = NaVeOl_Cripto.Resource1.h2;
        }

        private void pictureBox2_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox2.Image = NaVeOl_Cripto.Resource1.h1;
        }

        private void pictureBox1_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox1.Image = NaVeOl_Cripto.Resource1.f2;
        }

        private void pictureBox1_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox1.Image = NaVeOl_Cripto.Resource1.f1;
        }

        private void FormConfig_Load(object sender, EventArgs e)
        {

        }

        private void pictureBox3_Click(object sender, EventArgs e)
        {
            // select destention directory for ECO Out system
            {
                FolderBrowserDialog folderBrowserDialog = new FolderBrowserDialog();
                folderBrowserDialog.Description = "Select directory of ECO Out";
                folderBrowserDialog.ShowNewFolderButton = true;
                if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
                {
                    textBox2.Text = folderBrowserDialog.SelectedPath + "\\";
                    MCDE.GlobalVariable.directoryEcoOut = folderBrowserDialog.SelectedPath + "\\";
                }
            }
        }

        private void pictureBox3_MouseDown(object sender, MouseEventArgs e)
        {
            pictureBox2.Image = NaVeOl_Cripto.Resource1.h2;
        }

        private void pictureBox3_MouseUp(object sender, MouseEventArgs e)
        {
            pictureBox2.Image = NaVeOl_Cripto.Resource1.h1;
        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {
            MCDE.GlobalVariable.directoryEco = textBox1.Text;
        }

        private void textBox2_TextChanged(object sender, EventArgs e)
        {
            MCDE.GlobalVariable.directoryEcoOut = textBox2.Text;
        }
    }
}

Formdes2x

namespace NaVeOl_Cripto
{
    partial class FormConfig
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormConfig));
            this.checkBox1 = new System.Windows.Forms.CheckBox();
            this.checkBox2 = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.pictureBox2 = new System.Windows.Forms.PictureBox();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.pictureBox3 = new System.Windows.Forms.PictureBox();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).BeginInit();
            this.SuspendLayout();
            // 
            // checkBox1
            // 
            this.checkBox1.AutoSize = true;
            this.checkBox1.Location = new System.Drawing.Point(10, 98);
            this.checkBox1.Name = "checkBox1";
            this.checkBox1.Size = new System.Drawing.Size(109, 17);
            this.checkBox1.TabIndex = 0;
            this.checkBox1.Text = "Use file-password";
            this.checkBox1.UseVisualStyleBackColor = true;
            this.checkBox1.Visible = false;
            this.checkBox1.CheckedChanged += new System.EventHandler(this.checkBox1_CheckedChanged);
            // 
            // checkBox2
            // 
            this.checkBox2.AutoSize = true;
            this.checkBox2.Location = new System.Drawing.Point(10, 121);
            this.checkBox2.Name = "checkBox2";
            this.checkBox2.Size = new System.Drawing.Size(93, 17);
            this.checkBox2.TabIndex = 1;
            this.checkBox2.Text = "Use password";
            this.checkBox2.UseVisualStyleBackColor = true;
            this.checkBox2.Visible = false;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(204)));
            this.label1.ForeColor = System.Drawing.Color.MidnightBlue;
            this.label1.Location = new System.Drawing.Point(27, 3);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(92, 17);
            this.label1.TabIndex = 2;
            this.label1.Text = "Configuration";
            this.label1.Click += new System.EventHandler(this.label1_Click);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(7, 40);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(98, 13);
            this.label2.TabIndex = 4;
            this.label2.Text = "Directory Eco Input";
            // 
            // pictureBox1
            // 
            this.pictureBox1.Cursor = System.Windows.Forms.Cursors.IBeam;
            this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
            this.pictureBox1.Location = new System.Drawing.Point(292, 108);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(79, 30);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.pictureBox1.TabIndex = 5;
            this.pictureBox1.TabStop = false;
            this.pictureBox1.Click += new System.EventHandler(this.pictureBox1_Click);
            this.pictureBox1.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox1_MouseDown);
            this.pictureBox1.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox1_MouseUp);
            // 
            // pictureBox2
            // 
            this.pictureBox2.Image = global::NaVeOl_Cripto.Resource1.h1;
            this.pictureBox2.Location = new System.Drawing.Point(407, 40);
            this.pictureBox2.Name = "pictureBox2";
            this.pictureBox2.Size = new System.Drawing.Size(24, 24);
            this.pictureBox2.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox2.TabIndex = 6;
            this.pictureBox2.TabStop = false;
            this.pictureBox2.Click += new System.EventHandler(this.pictureBox2_Click);
            this.pictureBox2.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox2_MouseDown);
            this.pictureBox2.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox2_MouseUp);
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(121, 40);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(280, 20);
            this.textBox1.TabIndex = 7;
            this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(7, 71);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(106, 13);
            this.label3.TabIndex = 8;
            this.label3.Text = "Directory Eco Output";
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(119, 72);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(280, 20);
            this.textBox2.TabIndex = 10;
            this.textBox2.TextChanged += new System.EventHandler(this.textBox2_TextChanged);
            // 
            // pictureBox3
            // 
            this.pictureBox3.Image = global::NaVeOl_Cripto.Resource1.h1;
            this.pictureBox3.Location = new System.Drawing.Point(407, 72);
            this.pictureBox3.Name = "pictureBox3";
            this.pictureBox3.Size = new System.Drawing.Size(24, 24);
            this.pictureBox3.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox3.TabIndex = 9;
            this.pictureBox3.TabStop = false;
            this.pictureBox3.Click += new System.EventHandler(this.pictureBox3_Click);
            this.pictureBox3.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pictureBox3_MouseDown);
            this.pictureBox3.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pictureBox3_MouseUp);
            // 
            // FormConfig
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.AutoSize = true;
            this.ClientSize = new System.Drawing.Size(443, 183);
            this.Controls.Add(this.textBox2);
            this.Controls.Add(this.pictureBox3);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.pictureBox2);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.checkBox2);
            this.Controls.Add(this.checkBox1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.Name = "FormConfig";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Load += new System.EventHandler(this.FormConfig_Load);
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.CheckBox checkBox1;
        private System.Windows.Forms.CheckBox checkBox2;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.PictureBox pictureBox1;
        private System.Windows.Forms.PictureBox pictureBox2;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox textBox2;
        private System.Windows.Forms.PictureBox pictureBox3;
    }
}


Fornrex2

?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="pictureBox1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
        FtD9DydXKYSe0vnkAAAAAElFTkSuQmCC
</value>
  </data>
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAEAICAQAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAgAIAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//
        AAD///8ATExMTExMTMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM
        zMzMzMzMzM/8zMzMzMzMzMzMzMzMzMz//MzMzMzMzMzMzMzMzMzP/8zMzMzMz/jMzMzMzMzM//zMzMzM
        zH//hczMzMzMj//MzMzMzMyP//fMzMzMzP//jMzMzMzP////jMzMzMj///+MzMzM//+I//jMzMyP/4j/
        jMzMzP/4zI//zMzI//zI/4zMzMz//MzI//zMj//MzP+MzMzM//zMzM//iP/8zMz/jMzMzP/8zMzM///4
        zMzM/4zMzMz//MzMzI///MzMzP+MzMzM//zMzMyP//zMzMz/jMzMzP/8zMzM///4zMzM/4zMzMz//MzM
        yP///4zMzP/8zMzM//zMzM//iP/8zMz//MzMzP/8zMz/+FyP/8zM//zMzMz//MzI/4VcyP/MzP/8zMzM
        //jM//jMzMyP/Mj/jMzMzHj///+MzMzMyP//+HzMzMzMj///zMzMzMf//4zMzMzMzH//jMzMzMzMzMzM
        zMzMzMzP+MzMzMzMzMzMzMzMzMzM//fMzMzMzMzMzMzMzMzMz//MzMzMzMzMzMzMzMzMzM/8zMzMzMzM
        zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMxMTExMTExMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
</value>
  </data>
</root>


Supress

// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Waiting>", Scope = "member", Target = "~M:NaVeOl_Cripto.Form1.button1_Click(System.Object,System.EventArgs) ")]


<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{DD8C982E-8C46-41AE-A33C-870802AEFCFD}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>NaVeOl_Cripto</RootNamespace>
    <AssemblyName>NaVeOl_ECO</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>Icon2.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'проба|AnyCPU'">
    <OutputPath>bin\проба\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="Form2.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form2.Designer.cs">
      <DependentUpon>Form2.cs</DependentUpon>
    </Compile>
    <Compile Include="MCDE.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Resource1.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resource1.resx</DependentUpon>
    </Compile>
    <Compile Include="Verify.cs" />
    <EmbeddedResource Include="Form1.resx">
      <DependentUpon>Form1.cs</DependentUpon>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Include="Form2.resx">
      <DependentUpon>Form2.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>PublicResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
      <DesignTime>True</DesignTime>
    </Compile>
    <EmbeddedResource Include="Resource1.resx">
      <Generator>PublicResXFileCodeGenerator</Generator>
      <LastGenOutput>Resource1.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <None Include="a1.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="a2.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="d2.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="e1.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="e2.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="b1.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="b2.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="c1.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="c2.PNG" />
  </ItemGroup>
  <ItemGroup>
    <None Include="d1.PNG" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="DImg.bmp" />
    <None Include="f2.png" />
    <None Include="f1.png" />
    <None Include="DImg.png" />
    <Content Include="FImg.bmp" />
    <None Include="h2.png" />
    <None Include="h1.png" />
    <None Include="g2.png" />
    <None Include="g1.png" />
    <None Include="FImg.png" />
    <Content Include="Icon2.ico" />
    <None Include="Resources\Dimg.bmp" />
    <None Include="Resources\Fimg.bmp" />
    <None Include="jj1.png" />
    <None Include="jj2.png" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>

Mstoolpad
Mdecopy
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
// My Class Decoding Encoding
using System.Security.Cryptography;
using System.Windows.Forms;

namespace NaVeOl_Cripto
{
    internal class MCDE
    {

        internal class BitCounter
        {
            public static byte Bit1CountOfByte(byte Digit) // Count the number "1" in the byte
            {
                byte count = 0;
                for (int i = 0; i < 8; i++)
                {
                    if ((Digit >> i) % 2 == 1)
                        count++;
                }
                return count;
            }
            public static byte Bit1CountOfUint32(uint Digit)// Count the number "1" in uint 32
            {
                byte count = 0;
                for (int i = 0; i < 32; i++)
                {
                    if ((Digit >> i) % 2 == 1)
                        count++;
                }
                return count;
            }
            public static byte Bit1CountOfUlong64(ulong Digit) // Count the number "1" in ulong 64
            {
                byte count = 0;
                for (int i = 0; i < 64; i++)
                {
                    if ((Digit >> i) % 2 == 1)
                        count++;
                }
                return count;
            }
        }
        internal class Files
        {
            public static byte[] ReadBlockFromFile(string filePath, long offset, int blockSize = 512)
            {
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
                {
                    var buffer = new byte[blockSize];
                    fileStream.Seek(offset, SeekOrigin.Begin);
                    var bytesRead = fileStream.Read(buffer, 0, blockSize);
                    if (bytesRead == blockSize)
                    {
                        return buffer;
                    }
                    else if (bytesRead > 0)
                    {
                        var result = new byte[bytesRead];
                        Array.Copy(buffer, result, bytesRead);
                        return result;
                    }
                    else
                    {
                        return null;
                    }
                }
            }
            // Function 2 writes a block of data (256 bytes) from the file filePath, the starting position of the block in the file offset
            public static void WriteBlockToFile(string filePath, byte[] block, long offset, int blockSize = 512)
            {
                using (var fileStream = new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.Write))
                {
                    var buffer = new byte[blockSize];
                    if (block.Length == blockSize)
                    {
                        buffer = block;
                    }
                    else if (block.Length < blockSize)
                    {
                        Array.Copy(block, buffer, block.Length);
                    }
                    else
                    {
                        Array.Copy(block, buffer, blockSize);
                    }
                    fileStream.Seek(offset, SeekOrigin.Begin);
                    fileStream.Write(buffer, 0, blockSize);
                }
            }
            public static String OpenDialog(string Title, int p = 0)
            {
                using (OpenFileDialog openFileDialog = new OpenFileDialog())
                {
                    //openFileDialog.InitialDirectory = "c:\\";
                    if (p == 1) openFileDialog.Filter = "NaVeOl Eco files (*.nvl)|*.nvl|All files (*.*)|*.*";
                    //openFileDialog.FilterIndex = 2;
                    //openFileDialog.RestoreDirectory = true;
                    openFileDialog.Title = Title;

                    if (openFileDialog.ShowDialog() == DialogResult.OK)
                    {
                        //Get the path of specified file
                        return openFileDialog.FileName;
                    }
                    else { return ""; };
                }
            }

            public static String SaveDialog(string Title)
            {
                using (SaveFileDialog saveFileDialog = new SaveFileDialog())
                {
                    //openFileDialog.InitialDirectory = "c:\\";
                    //openFileDialog.Filter = "txt files (*.txt)|*.txt|All files (*.*)|*.*";
                    //openFileDialog.FilterIndex = 2;
                    //openFileDialog.RestoreDirectory = true;
                    saveFileDialog.Title = Title;
                    if (saveFileDialog.ShowDialog() == DialogResult.OK)
                    {
                        //Get the path of specified file
                        return saveFileDialog.FileName;
                    }
                    else { return ""; };
                }
            }
            /// <summary>
            /// Complements the RND file to a multiplicity of 512 and 
            /// adds another 1 of 512 block 
            /// and includes hiding the length of the source file into RND bloс.
            /// A random block is generated but not written but stored in a global variable
            /// </summary>
            /// <param name="b"></param>
            /// <param name="fileName"></param>
            public static long FileResize(string fileName)
            {
                // get and calculation info
                FileInfo info = new FileInfo(fileName);
                long size = info.Length; // length of the original file
                GlobalVariable.SizeSourceFile = size;
                long NBlocks = size / 512; // number of whole blocks in the file
                int EndTail = (int)(size - NBlocks * 512); // multiple 512 remainder - tail
                int Tail_Add = 512 - EndTail; // length of the piece to add to the tail up to the whole block
                                                            // generate a tail
                byte[] data = new byte[Tail_Add]; // declare an array to be added to the tail up to the whole block
                Randomize.RndTime1(data); // generate it
                                                       // generate another block 512 to add
                byte[] RndKey = new byte[512];
                Randomize.RndTime1(RndKey);
                //divide long into a byte array
                byte[] SizeByte = BitConverter.GetBytes(size);
                // Hide the bytes in the last block
                for (long i = 0; i < SizeByte.LongLength; i++)
                //for the inverse function - rearrange A=B^C <-> B=A^C
                { RndKey[i * i + 7] = (byte)(SizeByte[i] ^ RndKey[i + 87]); };
                // Open the file using FileStream and specify that we want to open the file for appending. 
                using (FileStream fs = new FileStream(fileName, FileMode.Append))
                {
                    fs.Write(data, 0, Tail_Add);
                    //fs.Write(RndKey, 0, 512); /// !!!! We do not write to the source, but only to the final RNA
                }   // Write the bytes to the end of the file     fs.Write(data, 0, data.Length);   }

                GlobalVariable.SizeTail = EndTail;
                GlobalVariable.SizeTail_Add = Tail_Add;
                GlobalVariable.EndRndBlock = RndKey;


                return size;
            }


            /// <summary>
            /// Complements the RND file to a multiplicity of 512 and 
            /// adds another 1 512 block 
            /// and includes the length of the source STREAM in it.
            /// </summary>
            /// <param name="b"></param>
            /// <param name="fileName"></param>
            /* *** It is necessary to add, but the idea is not to touch the source file
             //using System.IO;

                byte[] dataArray = { 0x01, 0x02, 0x03 };
             public static long StreamResize(string fileName)   
                using (FileStream fs = new FileStream("test.dat", FileMode.Append)) {
                    fs.Write(dataArray, 0, dataArray.Length);        // Append the byte array to the file stream  
                }
             */

            public static byte[] FileToMD5(string filename)
            {// find the HASH of the key file
                using (var md5 = MD5.Create())
                {
                    using (var stream = File.OpenRead(filename))
                    {
                        return md5.ComputeHash(stream);
                    }
                }
            }
        }
        // Global variables
        internal class GlobalVariable
        {
            public static bool demoVer = true;
            public static string currentDirectory = @"C:\";//*****
            public static string directoryEco = @"C:\NaVeOl_ECO\";
            public static string directoryEcoOut = @"C:\NaVeOl_ECO_out\";
            public static long SizeSourceFile;
            public static int SizeTail; // how much tail
            public static int SizeTail_Add;// how much to add
            public static byte[] EndRndBlock = new byte[512];// last random block with the length of the source file stitched into it
            public static byte[] FK = new byte[256]; // bullshit array to delay the program with unnecessary calculations
        }
        internal class Keys
        {
            public static string Pas_strech(string a)
            {
                if (a == "") a = ".";
                const int szPas = 32;
                byte[] R = new byte[szPas];
                byte[] L = new byte[szPas];
                int i, s = 1, p = 1, y = 1; int a_len = a.Length;

                for (i = 0; i != a_len; i++)
                {
                    s += a[i];
                    p *= a[i];
                    y += a[i] * 7 * i;
                }
                L[0] = (byte)(a[0] * s + p);
                for (i = 1; i != szPas; i++)
                    L[i] = (byte)((L[i - 1] ^ 715959500) * s * (byte)a[i % a_len] * i + (p + 1 + L[i - 1]) * i + y);
                for (i = 0; i != szPas; i++) R[i] = (byte)(L[i] % szPas);
                string rez = "";
                for (i = 0; i != szPas; i++)
                {
                    R[i] = (byte)((R[i] % 26) + 65); // restrictions on characters - only LARGE LAT
                    rez += (char)(R[i]);
                }
                return rez;
            }// Let's extend the password to 32 LATIN CASE characters
            public static byte[] StrechArray_byte512(byte[] a)
            {

                if (a.Length == 0) { a = Randomize.RndConst1(314159265, 512); };
                byte[] L = new byte[512];
                int i, s = 1, p = 1, y = 1;
                int a_len = a.Length;

                for (i = 0; i != a_len; i++)
                {
                    s += a[i];
                    p *= a[i];
                    y += a[i] * 7 * i;

                }
                L[0] = (byte)(a[0] * s + p);
                for (i = 1; i != 512; i++)
                {
                    L[i] = (byte)((L[i - 1] ^ 715959500) * s * a[i % a_len] * i + (p + 1 + L[i - 1]) * i + y);
                };

                a = Randomize.RndConst1(a[0], 512);// *** For small a<8 there may be an error
                for (i = 0; i != 512; i++)
                {
                    L[i] = (byte)(~L[i] ^ a[i]);
                }


                return L;
            }

            public static byte[] Pas_strechToArray512(string a)
            {
                if (a == "") { a = "Qwo0ck$8983jknsdlllsijjanz,x.ee!)^7f&?"; }
                else { a = a + "Qwo0ck$8983jknsdlllsijjanz,x.ee!)^7f&?" + Convert.ToString(a.Length * a.Max()); };
                const int szPas = 512;
                byte[] L = new byte[szPas];
                int i, s = 0xBAC356A, p = 0xABAC653, y = 0xFED1247; int a_len = a.Length;

                for (i = 0; i != a_len; i++)
                {
                    s += a[i];
                    p *= a[i];
                    y += a[i] * 7 * i;
                }
                L[0] = (byte)(a[0] * s + p);
                for (i = 1; i != szPas; i++)
                    L[i] = (byte)((L[i - 1] ^ 715959500) * s * (byte)a[i % a_len] * i + (p + 1 + L[i - 1]) * i + y);
                for (i = 0; i != (szPas - 3); i++) { L[i] = (byte)(L[i] * L[i + 1] / (L[i + 2] + 1)); }

                return L;
            }// Let's extend the password to 512 bytes
             //public static byte[] KeySeed()

            public static byte[] KeyFresh5(byte[] data)
            {
                for (int i = 0; i < data.Length - 1; i++)
                {
                    data[i] = (byte)(~data[i] ^ data[data.Length - i - 1] + data[i + 1]);
                    data[i] = Roling.ROR_QQShift((byte)~data[i], (byte)(i % 7 + 1));
                }
                return data;
            }

        } // working with keys


        internal class Mix
        {
            public struct Var2x64 // structure for exchanging bits
            {
                public head A;
                public head B;
            };
            public struct Var2x32
            {
                public uint A;
                public uint B;
            };
            public static Var2x64 MixK(Var2x64 Mix, ulong K)
            {
                head Ai = Mix.A & K;
                head Bii = Mix.B & K;
                K = ~K;
                //K ^= 0xffffffffffffffff;
                head Aii = Mix.A & K;
                head Bi = Mix.B & K;
                Mix.B = Food | Bi;
                Mix.A = Aii | Bii;
                return Mix;

            }//Exchange bits by key int64 <-> Int64
            public static Var2x32 MixK(Var2x32 Mix, uint K) // Exchange bits by key int32 <-> Int32
            {
                uint Ai = Mix.A & K;
                uint Bii = Mix.B & K;
                K = ~K;
                uint Aii = Mix.A & K;
                uint Bi = Mix.B & K;
                Mix.B = Food | Bi;
                Mix.A = Aii | Bii;
                return Mix;

                /* Usage description:
                Symmetric function for exchanging bits by key between two int32 variables
                Var2x64 Mix,MixA;
                Mix.A = 0xffffffff;
                Mix.B = 0x00000000;
                richTextBox1.AppendText(Convert.ToString(Mix.A) + "  " + Convert.ToString(Mix.B) + "\r\n");

                MixA = MixK(Mix, 0xFFFF0000);
                richTextBox1.AppendText(Convert.ToString(MixA.A)+ "  "+ Convert.ToString(MixA.B) + "\r\n");

                Mix = MixK(MixA, 0xFFFF0000);

                richTextBox1.AppendText(Convert.ToString(Mix.A) + "  " + Convert.ToString(Mix.B) + "\r\n");
                */
            }
            public static head RearrangeBits(head number)
            {
                head even_bits = number & 0xAAAAAAAAAAAAAAAA;
                ulong odd_bits = number & 0x5555555555555555;

                even_bits >>= 1;
                odd_bits <<= 1;

                return (even_bits | odd_bits);
            }// rearranges even and odd bits int64 comb 0101
            public static uint RearrangeBits(uint number)
            {
                uint even_bits = number & 0xAAAAAAAA;
                uint odd_bits = number & 0x55555555;

                even_bits >>= 1;
                odd_bits <<= 1;

                return (even_bits | odd_bits);
            }// rearranges even and odd bits int32 comb 0101
            public static uint MixBits6R(uint number)
            {
                uint even_bits = number & 0xAAAAAAAA;
                uint odd_bits = number & 0x55555555;
                even_bits = MCDE.Roling.ROR_QQShift(even_bits, 6);
                return (even_bits | odd_bits);
            }// rearranges the even and odd bits of int32 6 positions to the right comb 0101
            public static uint MixBits6L(uint number)
            {
                uint even_bits = number & 0xAAAAAAAA;
                uint odd_bits = number & 0x55555555;
                even_bits = MCDE.Roling.ROL_QQShift(even_bits, 6);
                return (even_bits | odd_bits);
            }// rearranges the even and odd bits of int32 by 6 positions left comb 0101
            public static uint MixBits1R(uint number)
            {
                uint even_bits = number & 0xCCCCCCCC;
                uint odd_bits = number & 0x33333333;
                even_bits = MCDE.Roling.ROR_QQShift(even_bits, 2);
                return (even_bits | odd_bits);
            }// rearranges the even and odd bits of int32 2 positions to the right comb 1100
            public static uint MixBits1L(uint number)
            {
                uint even_bits = number & 0x33333333;
                uint odd_bits = number & 0x33333333;
                even_bits = MCDE.Roling.ROL_QQShift(even_bits, 2);
                return (even_bits | odd_bits);
            }// rearranges the even and odd bits of int32 by 2 positions left comb 1100
            public static uint MixBits2R(uint number, byte K1, byte K2)
            {
                uint M = (uint)((K1 * 256 + K1) * 256 + K1) * 256 + K1; // make the key template F(x)
                byte Sh = (byte)((K2 % 3 + 1) * 8); // make a shift F(x) from the key
                uint even_bits = number & M;
                uint odd_bits = number & ~M;
                even_bits = MCDE.Roling.ROR_QQShift(even_bits, Sh);
                return (even_bits | odd_bits);
            }// rearranges int32 bits by key
            public static uint MixBits2L(uint number, byte K1, byte K2)
            {
                uint M = (uint)((K1 * 256 + K1) * 256 + K1) * 256 + K1; // make the key template F(x)
                byte Sh = (byte)((K2 % 3 + 1) * 8); // make a shift F(x) from the key
                uint even_bits = number & M;
                uint odd_bits = number & ~M;
                even_bits = MCDE.Roling.ROL_QQShift(even_bits, Sh);
                return (even_bits | odd_bits);
            }// rearranges int32 bits by key
            public static byte FlipByte(int Digt)
            {
                int B = Digt & 0x0f;
                int A = Poem & 0xf0;
                B <<= 4;
                A >>= 4;
                return Convert.ToByte(A | B);
            }// 0000 <-> 1111 exchange 4 bit Hi and Lo
            public static uint CODE32(uint A, uint K1, uint K2)
            {
                A ^= K1;
                A = MCDE.Roling.ROR_QQShift(~A, (byte)(K2 % 31));
                RearrangeBits(A);
                A ^= K1;
                A = MixBits6R(A);
                return A + K2;
            }
            public static uint UnCODE32(uint A, uint K1, uint K2)
            {
                A -= K2;
                A = MixBits6L(A);
                A ^= K1;
                RearrangeBits(A);
                A = MCDE.Roling.ROL_QQShift(~A, (byte)(K2 % 31));
                A ^= K1;
                return A;

            }

            public static byte EncodeROL5_QQ(byte number, byte[] MAT5)
            {// We do not load!!!! But it is necessary to check shift = 1..7
                // degree, in units, shift forward
                // transfers the bitmap
                // Copied the bits going into <-overflow, move the transferred part to the right
                byte buff = (byte)((number & 0b11111000) >> 3);
                // replace index-> ​​number
                buff = MAT5[buff];
                // and non-transportable to the left
                return (byte)(buff + (number << 5));
            }
            public static byte DecodeROR5_QQ(byte number, byte[] MATi5)
            {// We do not load!!!! But it is necessary to check shift = 1..7
                // transfers the bitmap
                byte buff = (byte)(number & 0b11111); // Copied bits going to ->overflow
                // restored the index->number value via reverse MATi
                buff = MATi5[buff];
                // move the portable part to the left, and the non-transportable part to the right
                return (byte)((buff << 3) + (number >> 5));

            }
        }
        internal class NaVeOl
        {
            public static byte Lower() // Slows down the program in Profesional - disabled
            {
                if (GlobalVariable.demoVer) // Demo
                {
                    for (int i = 0; i < 256; i++)
                    {
                        #region // Demo //K=2.16  
                        for (int k = 0; k < 4; k++)
                        {
                            GlobalVariable.FK[i] = (byte)(GlobalVariable.EndRndBlock[i]
                            / 5.15 * 9.85);
                        }
                        #endregion
                    }
                }
                else //release Version 2 Version 2 professional
                {
                    //for (int i = 0; i < 256; i++)
                    //{
                    // #region //Master //K=1.23
                    //    GlobalVariable.FK[i] = (byte)(GlobalVariable.EndRndBlock[i]
                    // / 5.15 * 9.85);//Master //K=1.23
                    //    #endregion
                    //    #region //Bat BAsic //K=1.6  
                    //    //for (int k = 0; k < 1; k++)
                    //    //{
                    //    //    GlobalVariable.FK[i] = (byte)(GlobalVariable.EndRndBlock[i]
                    //    //    / 5.15 * 9.85 + GlobalVariable.FK[i]);
                    //    //}
                    //    #endregion
                    //}

                }

                return 222;
            }






            /// <summary>
            /// Replaces the 7 lowest bits in a byte with the numbers 
            /// from the MAT by index, and leaves the highest bit unchanged. 
            /// Then the half-byte permutation function is applied. 
            /// Then again replaces the 7 lower bits in the byte 
            /// with the numbers from the MAT by index, 
            /// and leaves the higher bit unchanged.
            /// </summary>
            /// <param name="data"></param>
            /// <param name="MAT1"></param>
            /// <param name="MAT2"></param>
            /// <returns></returns>
            public static byte[] Encoding_IQ(byte[] data, byte[] MAT)
            {
                //Encode the input data, MAT using the IQ method
                for (int i = 0; i < data.Length; i++)
                {//Exchanging the 7 least significant bits of two numbers in an array //can't be shortened - you need a clipboard
                    byte C = (byte)(data[i] & 127); //selected 7 bits from 1
                    byte D = (byte)(data[MAT[i]] & 127); //selected 7 bits from 2
                    data[i] &= 128; // 7 bits cleared
                    data[MAT[i]] &= 128; // 7 bits cleared
                    // exchanged
                    data[i] |= D;
                    data[MAT[i]] |= C;

                };
                return data;
            }


            /// <summary>
            /// Replace the number with its index
            /// </summary>
            /// <param name="data"></param>
            /// <param name="MAT"></param>
            /// <returns></returns>
            public static byte[] Encoding_IQ2(byte[] data, byte[] MAT)
            {
                //Encode the input data, MATi using the IQ2 method
                for (int i = 0; i < data.Length; i++)
                {// replace the number with its index
                    data[i] = MAT[data[i]];
                };
                return data;
            }
            /// <summary>
            /// replace the index with the corresponding number
            /// </summary>
            /// <param name="data"></param>
            /// <param name="MATi"></param>
            /// <returns></returns>
            public static byte[] Decoding_IQ2(byte[] data, byte[] MATi)
            {
                //Encode the input data, MATi using the IQ2 method
                for (int i = 0; i < data.Length; i++)
                {// replace the number with its index
                    data[i] = MATi[data[i]];
                };
                return data;

            }


            /// <summary>
            /// Replaces the 7 lowest bits in a byte with the numbers 
            /// from the MAT by index, and leaves the highest bit unchanged. 
            /// Then the half-byte permutation function is applied. 
            /// Then again replaces the 7 lower bits in the byte 
            /// with the numbers from the MAT by index, 
            /// and leaves the higher bit unchanged.
            /// </summary>
            /// <param name="data"></param>
            /// <param name="MAT1"></param>
            /// <param name="MAT2"></param>
            /// <returns></returns>
            public static byte[] Encoding_I(byte[] data, byte[] MAT1, byte[] MAT2)
            {
                //Encode using method I the input data, MAT1, MAT2
                for (int i = 0; i < data.Length; i++)
                {// replace the 7 least significant bits of the number with the index of one of the MAT tables, leaving the most significant bit
                    if ((data[i] & 128) > 0)
                    { data[i] = NaVeOl.MatIndx2Num(data[i], MAT1); }
                    else { data[i] = NaVeOl.MatIndx2Num(data[i], MAT2); }
                };
                // in a byte we swap nibbles
                for (int i = 0; i < data.Length; i++) { data[i] = Mix.FlipByte(data[i]); };

                // encode again
                for (int i = 0; i < data.Length; i++)
                {// replace the 7 least significant bits of the number with the index of one of the MAT tables, leaving the most significant bit
                    if ((data[i] & 128) > 0)
                    { data[i] = NaVeOl.MatIndx2Num(data[i], MAT1); }
                    else { data[i] = NaVeOl.MatIndx2Num(data[i], MAT2); }
                };
                return data;
            }
            /// <summary>
            /// Decoding = Encoding only It is necessary 
            /// to prepare MAT 1 and MA2 for decoding 
            /// using the functions
            /// MAT1 =NaVeOl.MatTableReplaceIndx2Num(MAT1);
            /// MAT2=NaVeOl.MatTableReplaceIndx2Num(MAT2);
            /// </summary>
            /// <param name="data"></param>
            /// <param name="MAT1"></param>
            /// <param name="MAT2"></param>
            /// <returns></returns>
            public static byte[] Decoding_I(byte[] data, byte[] MAT1, byte[] MAT2)
            { // don't forget to flip tables MAT1 MAT2 replacing values ​​with indexes and vice versa
                return Encoding_I(data, MAT1, MAT2);
            }
            /// <summary>
            /// We look for the index and replace it with the value from the table
            /// </summary>
            /// <param name="data"></param>
            /// <param name="MAT8"></param>
            /// <returns></returns>
            public static byte[] Encoding_II(byte[] data, byte[] MAT8)
            {
                for (int i = 0; i < data.Length; i++)
                {
                    data[i] = MAT8[data[i]];
                }
                return data;
            }
            /// <summary>
            /// We look for the index and replace it with the value from the table
            /// But first the tables need to be turned over by exchanging indexes and values
            /// </summary>
            /// <param name="data"></param>
            /// <param name="MAT8"></param>
            /// <returns></returns>
            public static byte[] Decoding_II(byte[] data, byte[] MAT8)
            {
                for (int i = 0; i < data.Length; i++)
                {
                    data[i] = MAT8[data[i]];
                }
                return data;
            }
            /// <summary>
            /// Pseudo-random permutation of MAT table numbers
            /// </summary>
            /// <param name="MAT"></param>
            /// <param name="seed"></param>
            /// <returns></returns>
            public static byte[] FreshMAT(byte[] MAT, int seed)//   1.7 s/18Mb
            {


                List<byte> numbers = new List<byte>(MAT.Length);
                for (int i = 0; i < MAT.Length; i++)
                {
                    numbers.Add(MAT[i]);
                }

                byte[] result = new byte[MAT.Length];
                Random random = new Random(seed);
                for (int i = 0; i < MAT.Length; i++)
                {
                    int index = random.Next(numbers.Count);
                    result[i] = numbers[index];
                    numbers.RemoveAt(index);
                }
                //
                return result;
            }
            public static byte[] FreshQMAT(byte[] MAT, int varSeed)//   1.7 s/18Mb
            {
                switch ((varSeed + MAT[(byte)varSeed]) & 15)
                {
                    case 0:
                        Array.Reverse(MAT);
                        break;
                    case 1:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = (byte)~MAT[i];
                        }
                        break;
                    case 2:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = (byte)(MAT[i] ^ 181);
                        }
                        break;
                    case 3:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = (byte)(MAT[i] ^ 91);
                        }
                        break;
                    case 4:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = (byte)(MAT[i] ^ 203);
                        }
                        break;
                    case 5:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = Roling.ROR_QQShift(MAT[i], 1);
                        }
                        break;
                    case 6:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = Roling.ROR_QQShift(MAT[i], 4);
                        }
                        break;
                    case 7:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = Roling.ROR_QQShift(MAT[i], 5);
                        }
                        break;
                    case 8:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] = Roling.ROL_QQShift(MAT[i], 3);
                        }
                        break;
                    case 9:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] += 191;
                        }
                        break;
                    case 10:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] += 244;
                        }
                        break;
                    case 11:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] += 111;
                        }
                        break;
                    case 12:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] += 45;
                        }
                        break;
                    case 13:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] += 14;
                        }
                        break;
                    case 14:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] += 86;
                        }
                        break;

                    default:
                        for (int i = 0; i < MAT.Length; i++)
                        {
                            MAT[i] += 77;
                        }
                        break;
                }
                //
                return MAT;
            }

            /// <summary>
            /// Fast Pseudo-random permutation
            /// arbitrary KEY table
            /// </summary>
            /// <param name="MAT"></param>
            /// <param name="seed"></param>
            /// <returns></returns>
            public static byte[] FreshQKey(byte[] Key5, int seed)  //  1.8s/18Mb
            {
                List<byte> numbers = new List<byte>(Key5.Length);
                for (int i = 0; i < Key5.Length; i++)
                {
                    numbers.Add(Key5[i]);
                }

                byte[] result = new byte[Key5.Length];
                Random random = new Random(seed);
                for (int i = 0; i < Key5.Length; i++)
                {
                    int index = random.Next(numbers.Count);
                    result[i] = numbers[index];
                    numbers.RemoveAt(index);
                }
                //
                return result;
            }
            public static byte[] FreshQQKey(byte[] Key5, byte[] MAT, int seed)  //  s/18Mb
            {
                Key5.Reverse();
                for (int i = 0; i < 256; i++)
                {
                    Key5[i] = (byte)(Key5[i] + Key5[i + 127] + MAT[255 - i]);
                }


                //
                return Key5;
            }
            public static byte[] TransposeMatrix64bit8byteArray(byte[] b)//  0.04s/18Mb
            {
                ////if ((b.Length > 8) | (b.Length < 8)) { MessageBox.Show("b.Length array only 8 byte!"); }
                // NaVeOl transformation //RearrangeBits
                head A;
                A = BitConverter.ToUInt64(b, 0);
                ulong v = Roling.TransposeBitMatrix(A);
                A = v;
                return BitConverter.GetBytes(A);
            }
            public static byte[] EnCodeTransposeMatrix64bit8byteArrayAndBitPermutation(byte[] b)
            {
                ////if ((b.Length > 8) | (b.Length < 8)) { MessageBox.Show("b.Length array only 8 byte!"); }
                ////// NaVeOl transformation //RearrangeBits
                head A;

                A = BitConverter.ToUInt64(b, 0);
                ulong v = MCDE.Roling.TransposeBitMatrix(A);
                A = Mix.RearrangeBits(v);
                return BitConverter.GetBytes(A);
            }
            public static byte[] DeCodeTransposeMatrix64bit8byteArrayAndBitPermutation(byte[] b)
            {
                ////if ((b.Length > 8) | (b.Length < 8)) { MessageBox.Show("b.Length array only 8 byte!"); }
                // NaVeOl transformation //RearrangeBits
                head A;

                A = BitConverter.ToUInt64(b, 0);
                ulong v = Mix.RearrangeBits(A);
                A = MCDE.Roling.TransposeBitMatrix(v);

                return BitConverter.GetBytes(A);
            }
            public static byte[] GenMat7bit(int seed)
            {
                byte[] MAT = new byte[128];
                MAT = Randomize.SeedGenerateUniqueRandomNumbers(128, seed);
                return MAT;
            }//New MAT 7 bit
            public static byte[] GenMat8bit(int seed)
            {
                byte[] MAT = new byte[256];
                MAT = Randomize.SeedGenerateUniqueRandomNumbers(256, seed);
                return MAT;
            }//New MAT 8 bit

            public static byte[] GenMat6bit(int seed)
            {
                byte[] MAT = new byte[64];
                MAT = Randomize.SeedGenerateUniqueRandomNumbers(64, seed);
                return MAT;
            }//New MAT 6 bit
            public static byte[] GenMat5bit(int seed)
            {
                byte[] MAT = new byte[32];
                MAT = Randomize.SeedGenerateUniqueRandomNumbers(32, seed);
                return MAT;
            }//New MAT 6 bit

            //public static byte Mat7Num2IndxFlip(byte num, byte[] MAT)
            //{ number = (byte)(number & 127);
            //    for (int i = 0; i < MAT.Length; i++) { if (MAT[i] == num) { num = (byte)i ;break; } };
            // return whether;
            //}//Used MAT 7 bit EnChange 1 byte number2index
            ////Long non Lineal Function
            /// <summary>
            ///  EnChange indx to number from MAT 7bit
            /// </summary>
            /// <param name="indx"></param>
            /// <param name="MAT"></param>
            /// <returns></returns>
            public static byte MatIndx2Num(byte indx, byte[] MAT)
            {
                //byte result;
                //result = (byte)(indx & 127);// cut off the first bit
                //result = MAT[result];// replaced with index
                //result = (byte)(result | (indx & 128));// pasted the high bit
                return (byte)(MAT[(byte)(indx & 127)] | (indx & 128));
            }
            /// <summary>
            /// WITH 0:2 1:0 2:1 <=> 0:1 1:2 2:0
            /// </summary>
            /// <param name="MAT"></param>
            /// <returns></returns>
            public static byte[] MatTableReplaceIndx2Num(byte[] MAT)//MAT any Length EnChange index<->number
            {
                byte[] result = new byte[MAT.Length];
                for (int i = 0; i < MAT.Length; i++)
                {
                    result[MAT[i]] = (byte)i;
                }
                return result;
            }

        }

        internal class Randomize
        {
            /// <summary>
            /// generator psevdo randomize number
            /// </summary>
            /// <param name="Number"></param>
            /// <param name="Key"></param>
            /// <param name="Deep"></param>
            /// <returns></returns>
            public static uint RndConst_(uint Number, uint Key, uint Deep)
            {


                Deep += 11;
                for (uint i = 0; i < Deep; i++)
                {
                    Key += 7;
                    Number = (Number ^ 0xAAAA) * Key;
                }
                return Number;
            }
            public static double RndConst(int Min, int Max, int Seed)
            {
                // Create a new random object with the same seed value each time.  
                Random rand = new Random(Seed);

                // Generate a random number and store it in 'previous' variable.   
                return rand.NextDouble() * (Max - Min) + Min;
            }
            public static byte[] RndConst1(int Seed, uint LenArray)
            {

                byte[] data = new byte[LenArray];
                // Create a new random object with the same seed value each time.  
                Random rand = new Random(Seed);
                // debug - check
                if ((Seed > 65537) | (LenArray > 1000000)) { MessageBox.Show("Very big number!"); };
                // Generate a random number and store it in 'previous' variable.   
                rand.NextBytes(data);
                return data;
            }
            public static void RndTime1(byte[] Array)
            {
                //int LenArray = Array.Length;
                RandomNumberGenerator rng = RandomNumberGenerator.Create();
                // Generate 4 bytes of random data        
                //byte[] data = new byte[4];
                rng.GetBytes(Array);
            }
            public static byte RndTime1()
            {
                RandomNumberGenerator rng = RandomNumberGenerator.Create();
                byte[] data = new byte[1];
                rng.GetBytes(data);
                return data[0];
            }

            /// <summary>
            /// Generate a byte array of length LenArray
            /// Numbers in the range 1..255 (without 0)
            /// The values ​​are different each time you run
            /// </summary>
            /// <param name="LenArray"></param>
            /// <returns></returns>
            public static byte[] RndTimeNZConst(int LenArray)
            {
                RandomNumberGenerator rng = RandomNumberGenerator.Create();
                // Generate 8 bytes of non-zero random data ( Non seed! )     
                byte[] data = new byte[LenArray];
                rng.GetNonZeroBytes(data);
                return data;
            }

            /// <summary>
            /// A byte array of length size is generated
            /// Numbers in the range 0..size, one of each
            /// The values ​​are different each time you run
            /// </summary>
            /// <param name="size"></param>
            /// <returns></returns>
            public static byte[] GenerateUniqueRandomNumbers(int size)
            {
                ////if (size > 256)
                ////{
                ////    MessageBox.Show("Size must be less than or equal to 256.(byte size)");
                ////}

                List<byte> numbers = new List<byte>(size);
                for (byte i = 0; i < size; i++)
                {
                    numbers.Add(i);
                }

                byte[] result = new byte[size];
                Random random = new Random();
                for (int i = 0; i < size; i++)
                {
                    int index = random.Next(numbers.Count);
                    result[i] = numbers[index];
                    numbers.RemoveAt(index);
                }

                return result;
            }

            /// <summary>
            /// generator absolutely randomize number
            /// </summary>
            /// <param name="Deep"></param>
            /// <returns></returns>
            public static uint RndDeep(uint Deep = 3)
            {
                DateTime now = DateTime.Now;
                long bigIntegerNumber = now.Ticks;
                uint Number = Convert.ToUInt32(bigIntegerNumber & 0xffffffff);
                uint Key = MCDE.Roling.ROL_QQShift(Number, 7);
                uint n = Number % 10;
                Deep += n;
                for (uint i = 0; i < Deep; i++)
                {
                    Number = (Number ^ 0xAAAA) * Key;
                }
                return Number;
            }

            /// <summary>
            /// Generate Seed Random Numbers size = MaxNum+1  Only Unique Numers
            /// Example:8  - 0..7
            ///         64 - 0..63
            ///         128 - 0..127
            ///         256 - 0..255
            /// </summary>
            /// <param name="size"></param>
            /// <param name="seed"></param>
            /// <returns></returns>
            public static byte[] SeedGenerateUniqueRandomNumbers(int size, int seed = 42)
            {
                byte[] data = new byte[size];
                //
                ////if (size > 256)
                ////{
                ////    MessageBox.Show("Size must be less than or equal to 256.(byte size)");
                ////}

                List<byte> numbers = new List<byte>(size);
                for (int i = 0; i < size; i++)
                {
                    numbers.Add((byte)i);
                }

                byte[] result = new byte[size];
                Random random = new Random(seed);
                for (int i = 0; i < size; i++)
                {
                    int index = random.Next(numbers.Count);
                    result[i] = numbers[index];
                    numbers.RemoveAt(index);
                }



                //
                return result;
            }//+++
        }
        /*  void keyGen() 
        {
            byte i = 0;
            while (true)
            {
                code(key[i ^ 77], key[cast(ubyte)(i + 1) ^ 77], key[i ^ cast(ubyte)(27 + i)], key[cast(ubyte)(i + 1) ^ cast(ubyte)(55 + i)], key[i ^ cast(ubyte)(114 + i)]);
                if (i++ == 254) break;
            }
        }*/ // Additional key obfuscation
        internal class Roling
        {



            public static byte ROL_QQShift(byte number, int shift)
            {// We do not load!!!! But it is necessary to check shift = 1..7
                // degree, in units, shift forward
                byte bitTemplate = (byte)(((2 << shift) - 1) << (8 - shift)); // bit transfer template
                byte buff = (byte)(number & bitTemplate); // Copied bits going into <-overflow
                // move the portable part to the right, and the non-transportable part to the left
                return (byte)((buff >> (8 - shift)) + (number << shift));
            }
            public static byte ROR_QQShift(byte number, int shift)
            {// We do not load!!!! But it is necessary to check shift = 1..7
                // degree, in units
                byte bitTemplate = (byte)((2 << shift) - 1); // bit transfer template
                byte buff = (byte)(number & bitTemplate); // Copied bits going to ->overflow
                // move the portable part to the left, and the non-transportable part to the right
                return (byte)((buff << (8 - shift)) + (number >> shift));

            }
            public static uint ROL_QQShift(uint number, int shift)
            {// We do not load!!!! But it is necessary to check shift = 1..31
                // degree, in units, shift forward
                uint bitTemplate = ((2u << shift) - 1) << (32 - shift); // bit transfer template
                uint buff = (number & bitTemplate); // Copied bits going into <-overflow
                // move the portable part to the right, and the non-transportable part to the left
                return (buff >> (32 - shift)) + (number << shift);
            }
            public static uint ROR_QQShift(uint number, int shift)
            {// We do not load!!!! But it is necessary to check shift = 1..31
                // degree, in units
                uint bitTemplate = (2u << shift) - 1; // shift bit template
                uint buff = number & bitTemplate; // Copied bits going to ->overflow
                // move the portable part to the left, and the non-transportable part to the right
                return ((buff << (32 - shift)) + (number >> shift));

            }
            public static head ROL_QQShift(head number, int shift)
            {// We do not load!!!! But it is necessary to check shift = 1..63
                // degree, in units, shift forward
                ulong bitTemplate = ((2u << shift) - 1) << (64 - shift); // shift bit template
                ulong buff = (number & bitTemplate); // Copied bits going into <-overflow
                // move the portable part to the right, and the non-transportable part to the left
                return (buff >> (64 - shift)) + (number << shift);
            }
            public static ulong ROR_QQShift(ulong number, int shift)
            {// We do not load!!!! But it is necessary to check shift = 1..31
                // degree, in units
                ulong bitTemplate = (2u << shift) - 1; // shift bit template
                ulong buff = number & bitTemplate; // Copied bits going to ->overflow
                // move the portable part to the left, and the non-transportable part to the right
                return (buff << (63 - shift)) + (number >> shift);

            }




            /// <summary>
            /// Input byte,ushort,uint,ulong
            /// Output boolean[8]...boolean[64]+
            /// </summary>
            /// <returns></returns>
            public static Boolean[] NumberToBooleanArray(dynamic Number)
            {
                Type TType = Number.GetType();
                bool[] boolArray = new bool[64];



                if (TType == typeof(byte))
                {
                    byte b = Number; // Example byte value
                    Array.Resize(ref boolArray, 8);
                    for (int i = 0; i < 8; i++)
                    {
                        boolArray[i] = (b & (1 << i)) != 0;
                    }

                }
                if (TType == typeof(ushort))
                {
                    ushort b = Number; // Example byte value

                    Array.Resize(ref boolArray, 16);
                    for (int i = 0; i < 16; i++)
                    {
                        boolArray[i] = (b & (1 << i)) != 0;
                    }

                }
                if (TType == typeof(uint))
                {
                    uint b = Number; // Example byte value

                    Array.Resize(ref boolArray, 32);
                    for (int i = 0; i < 32; i++)
                    {
                        boolArray[i] = (b & (1 << i)) != 0;
                    }

                }
                if (TType == typeof(head))
                {
                    ulong b = Number; // Example byte value

                    // Array.Resize(ref boolArray, 64);
                    for (int i = 0; i < 64; i++)
                    {
                        boolArray[i] = (b & (head)(1 << i)) != 0;
                    }

                }


                return boolArray;
            }

            /// <summary>
            /// Input boolean[8]...boolean[64]
            /// Output byte, ushort, uint, head
            /// </summary>
            /// <param name="boolArray"></param>
            /// <returns></returns>

            public static dynamic BooleanArrayToNumber(bool[] boolArray)
            {
                int L = boolArray.Length;
                byte DataType = 0;
                byte b8 = 0;
                byte b16 = 0;
                byte b32 = 0;
                byte b64 = 0;


                switch (L)
                {
                    case int n when n < 9:

                        for (int i = 0; i < 8; i++)
                        {
                            if (boolArray[i])
                            {
                                b8 |= (byte)(1 << i);
                            }
                        }

                        DataType = 8;
                        break;
                    case int n when n > 8 && n < 17:
                        for (int i = 0; i < 16; i++)
                        {
                            if (boolArray[i])
                            {
                                b16 |= (byte)(1 << i);
                            }
                        }

                        DataType = 16;
                        break;
                    case int n when n > 16 && n < 33:
                        for (int i = 0; i < 32; i++)
                        {
                            if (boolArray[i])
                            {
                                b32 |= (byte)(1 << i);
                            }
                        }

                        DataType = 32;
                        break;
                    case int n when n > 32 && n < 65:
                        for (int i = 0; i < 64; i++)
                        {
                            if (boolArray[i])
                            {
                                b64 |= (byte)(1 << i);
                            }
                        }

                        DataType = 64;
                        break;
                }

                switch (DataType)
                {
                    case 8:
                        return b8;
                        break;
                    case 16:
                        return b16;
                        break;
                    case 32:
                        return b32;
                        break;
                    case 64:
                        return b64;
                        break;
                    default:
                        return "Error Length Bollean Array";
                }




            }


            public static bool[] ByteToBooleanArray(byte Number)
            {
                bool[] boolArray = new bool[8];
                for (int i = 0; i < 8; i++)
                {
                    boolArray[i] = (Number & (1 << i)) != 0;
                }
                return boolArray;
            }
            public static byte BooleanArrayToByte(bool[] boolArray)
            {
                byte b8 = 0;
                for (int i = 0; i < 8; i++)
                {
                    if (boolArray[i])
                    {
                        b8 |= (byte)(1 << i);
                    }
                }
                return b8;
            }


            public static byte ByteToByteBitMix1(byte b)//, byte[]MAT8)
            {
                bool[] boolArray = new bool[8];
                byte b8 = 0;
                for (int i = 0; i < 8; i++)
                {
                    boolArray[i] = (b & (1 << i)) != 0;
                }

                ////And here is the rearrangement


                for (int i = 0; i < 8; i++)
                {
                    if (boolArray[i])
                    {
                        b8 |= (byte)(1 << i);
                    }
                }
                return b8;

            }  //1.56


            public static ulong UlongToUlongBitMix1(ulong b)//, byte[]MAT8)//2.57
            {
                bool[] boolArray = new bool[64];
                head b64 = 0;
                for (int i = 0; i < 64; i++)
                {
                    boolArray[i] = (b & (1UL << i)) != 0;
                }

                ////And here is the rearrangement


                for (byte i = 0; i < 64; i++)
                {
                    if (boolArray[i])
                    {
                        b64 |= (1UL << i);
                    }
                }
                return b64;

            }  //1.56





            public static head TransposeBitMatrix(head input)
            {
                head result = 0;

                for (int i = 0; i < 8; i++)
                {
                    for (int j = 0; j < 8; j++)
                    {
                        result |= ((input >> ((i << 3) + j)) & 1) << ((j << 3) + i);
                    }
                }

                return result;
            }//works symmetrically

            public static byte[] EncodeTransposeBitMatrix(byte[] input)
            {
                byte[] result = new byte[8];
                int RNA = 0;
                head DNA = 0;

                for (int i = 0; i < 8; i++)
                {
                    RNA = RNA >> 1;
                    RNA = RNA + (input[i] & 128); //the first bits are collected in a byte
                }
                for (int i = 0; i < 8; i++)
                {
                    DNA = DNA << 7;
                    DNA = DNA + (ulong)(input[i] & 127); //7 least significant bits collected in a byte
                }


                DNA = (DNA << 8) + (ulong)RNA; // NaVeOl encoding the result was added into an 8 byte array
                result = BitConverter.GetBytes(DNA);
                return result;
            }

            public static byte[] DecodeTransposeBitMatrix(byte[] input)
            {
                byte[] result = new byte[8];
                head RNA = 0;
                head DNA = 0;
                for (int i = 0; i < 8; i++) { result[i] = 0; }

                DNA = BitConverter.ToUInt64(input, 0);
                RNA = (byte)DNA; DNA = DNA >> 8;
                for (int i = 7; i >= 0; i--)
                {
                    result[i] = (byte)((DNA & 127) + (RNA & 128));
                    DNA = DNA >> 7;
                    RNA = RNA << 1;
                }
                return result;
            }



            /// <summary>
            /// Mixing Bytes in two arrays 256+256 = 512
            /// </summary>
            /// <param name="Mb"></param>
            /// <param name="K1"></param>
            /// <param name="K2"></param>
            public static void MixByteArr512(byte[] Mb, byte K1 = 0xAA, byte K2 = 0x33)
            {

                byte A;
                if (Mb.Length == 512) { return; };
                for (int i = 0; i < 256; i++)
                { // Reversibly mixed block at 512
                    A = Mb[(byte)(i ^ K1)];
                    Mb[(byte)(i ^ K1)] = Mb[256 + (byte)(i ^ K2)];
                    Mb[256 + (byte)(i ^ K2)] = A;

                }

            }
            public static void UnMixByteArr512(byte[] Mb, byte K1 = 0xAA, byte K2 = 0x33)
            {
                MixByteArr512(Mb, K1, K2);
            }



        }


}



<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
  </PropertyGroup>
  <PropertyGroup>
    <ProjectView>ProjectFiles</ProjectView>
    <PublishUrlHistory>publish\</PublishUrlHistory>
    <InstallUrlHistory />
    <SupportUrlHistory />
    <UpdateUrlHistory />
    <BootstrapperUrlHistory />
    <ErrorReportUrlHistory />
    <FallbackCulture>ru-RU</FallbackCulture>
    <VerifyUploadedFiles>false</VerifyUploadedFiles>
  </PropertyGroup>
</Project>



Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.5.33516.290
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NaVeOl_Cripto", "NaVeOl_Cripto.csproj", "{DD8C982E-8C46-41AE-A33C-870802AEFCFD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DD8C982E-8C46-41AE-A33C-870802AEFCFD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DD8C982E-8C46-41AE-A33C-870802AEFCFD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DD8C982E-8C46-41AE-A33C-870802AEFCFD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DD8C982E-8C46-41AE-A33C-870802AEFCFD}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FD327E46-5BCB-476B-A94A-CE6271F1BA50}
	EndGlobalSection
EndGlobal



using System;
using System.Windows.Forms;

namespace NaVeOl_Cripto
{
    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}


Resdgnb
//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by the program.
// Executable version: 4.0.30319.42000
//
// Changes to this file may cause incorrect operation and will be lost if
// re-generation of code.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NaVeOl_Cripto {
    using System;
    
    
    /// <summary>
    /// Strongly typed resource class for finding localized strings, etc.
    /// </summary>
    // This class is created automatically by the StronglyTypedResourceBuilder class
    // using a tool such as ResGen or Visual Studio.
    // To add or remove a member, modify the .ResX file and run ResGen again
    // with the /str parameter or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Resource1 {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resource1() {
        }
        
        /// <summary>
        /// Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("NaVeOl_Cripto.Resource1", typeof(Resource1).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        /// Overwrites the CurrentUICulture property of the current thread for all
        /// accesses a resource using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap a1 {
            get {
                object obj = ResourceManager.GetObject("a1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap a2 {
            get {
                object obj = ResourceManager.GetObject("a2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap b1 {
            get {
                object obj = ResourceManager.GetObject("b1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap b2 {
            get {
                object obj = ResourceManager.GetObject("b2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap c1 {
            get {
                object obj = ResourceManager.GetObject("c1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap c2 {
            get {
                object obj = ResourceManager.GetObject("c2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap d1 {
            get {
                object obj = ResourceManager.GetObject("d1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap d2 {
            get {
                object obj = ResourceManager.GetObject("d2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap DImg {
            get {
                object obj = ResourceManager.GetObject("DImg", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap DImg1 {
            get {
                object obj = ResourceManager.GetObject("DImg1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap e1 {
            get {
                object obj = ResourceManager.GetObject("e1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap e2 {
            get {
                object obj = ResourceManager.GetObject("e2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap f1 {
            get {
                object obj = ResourceManager.GetObject("f1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap f2 {
            get {
                object obj = ResourceManager.GetObject("f2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap FImg {
            get {
                object obj = ResourceManager.GetObject("FImg", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap FImg1 {
            get {
                object obj = ResourceManager.GetObject("FImg1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap g1 {
            get {
                object obj = ResourceManager.GetObject("g1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap g2 {
            get {
                object obj = ResourceManager.GetObject("g2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap h1 {
            get {
                object obj = ResourceManager.GetObject("h1", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        /// Search for a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        public static System.Drawing.Bitmap h2 {
            get {
                object obj = ResourceManager.GetObject("h2", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}



17 123 636 bytes
Speed

2851
31 32 33 34

2650
31 32 34 34

1394 
31  34

1312
31

743
0

713
keyFile 512

Description		function number	time ms		%
Cycle			0				743				26,1
Addition		1				569				20,0
Transposition	2				1174			41,2
Mat1/Mat2		3				119				4,2
MAT256			4				82				2,9





using System;
using System.IO;
using System.Text;

namespace NaVeOl_Cripto
{
    internal class Verify
    {
        #region Global variables
        public static string charLS = "";
        public static string charSN = "";
        public static string charID = "";
        #endregion

        public static string GenerateSerialNumber(string licenseNumber)
        {
            string characters = licenseNumber + Verify.charSN;
            int minLength = 256;
            int maxLength = 512;
            int Mix = 0x9028734;
            Random random = new Random(Mix);
            int length = random.Next(minLength, maxLength + 1);
            StringBuilder sb = new StringBuilder(length);
            for (int i = 0; i < length; i++)
            {
                int index = random.Next(characters.Length);
                sb.Append(characters[index]);
            }

            return sb.ToString();
        }
        public static string GenerateIdNumber(string serialNumber)
        {
            string characters = serialNumber + Verify.charID;
            int minLength = 256;
            int maxLength = 512;
            int Mix = 0x1F222A79;
            Random random = new Random(Mix);
            int length = random.Next(minLength, maxLength + 1);
            StringBuilder sb = new StringBuilder(length);
            for (int i = 0; i < length; i++)
            {
                int index = random.Next(characters.Length);
                sb.Append(characters[index]);
            }

            return sb.ToString();
        }
        public static bool SN_ID_DemoChecker()
        {
            int version = 2;
            #region This Generaate UNICUM string 
            string characters = "dgr3GHHTtNBVT64kggf574hLen3ldapdLEPODm3e998dmMLwlkdaakdlkmdwl3" +
                                "DjDJEIuSlcdlamnlx298djcPoodKKDNJElsWZZCdko89ckJNDjknghVFfdgssw";
            int minLength = 512;
            int maxLength = 1024;
            int Mix = 0x9872623;

            Random random = new Random(Mix + version);
            int length = random.Next(minLength, maxLength + 1);

            StringBuilder sb = new StringBuilder(length);
            for (int i = 0; i < length; i++)
            {
                int index = random.Next(characters.Length);
                sb.Append(characters[index]);
            }
            Verify.charLS = sb.ToString();
            sb.Clear();

            for (int i = 0; i < Verify.charLS.Length; i++)
            {
                int index = random.Next(Verify.charLS.Length);
                sb.Append(Verify.charLS[index]);
            }
            Verify.charSN = sb.ToString();
            sb.Clear();

            for (int i = 0; i < Verify.charSN.Length; i++)
            {
                int index = random.Next(Verify.charSN.Length);
                sb.Append(Verify.charSN[index]);
            }
            Verify.charID = sb.ToString();

            #endregion

            #region Read SN (serial number) from file 
            string filePath = "serial.ini";
            string serialNumber = "";

            // Read file
            string[] lines = File.ReadAllLines(filePath);

            // Check file to 3 lines
            if (lines.Length >= 3)
            {
                // get line 3
                serialNumber = lines[2];
            }
            else
            {
                
            }
            #endregion

            #region Reduce SN to ID 
            string IDx = GenerateIdNumber(serialNumber);
            #endregion
            #region read ID from file             
            filePath = "id.ini";
            string ID = "";

            


            lines = File.ReadAllLines(filePath);

            
            if (lines.Length >= 3)
            {                
                ID = lines[2];
            }
            else
            {
                
            }
            #endregion
            
            return IDx == ID;
        }
        public static bool LS_SN_RealizeChecker()
        {
            int version = 2;
            #region And here we generate a string unique for the version
            string characters = "dgr3GHHTtNBVT64kggf574hLen3ldapdLEPODm3e998dmMLwlkdaakdlkmdwl3" +
                                "DjDJEIuSlcdlamnlx298djcPoodKKDNJElsWZZCdko89ckJNDjknghVFfdgssw";
            int minLength = 512;
            int maxLength = 1024;
            int Mix = 0xFADABAC;

            Random random = new Random(Mix + version);
            int length = random.Next(minLength, maxLength + 1);

            StringBuilder sb = new StringBuilder(length);
            for (int i = 0; i < length; i++)
            {
                int index = random.Next(characters.Length);
                sb.Append(characters[index]);
            }
            Verify.charLS = sb.ToString();
            sb.Clear();

            for (int i = 0; i < Verify.charLS.Length; i++)
            {
                int index = random.Next(Verify.charLS.Length);
                sb.Append(Verify.charLS[index]);
            }
            Verify.charSN = sb.ToString();
            sb.Clear();

            for (int i = 0; i < Verify.charSN.Length; i++)
            {
                int index = random.Next(Verify.charSN.Length);
                sb.Append(Verify.charSN[index]);
            }
            Verify.charID = sb.ToString();

            #endregion

            #region Read SN from file 
            string filePath = "serial.ini";
            string SN = "";

            
            string[] lines = File.ReadAllLines(filePath);

           
            if (lines.Length >= 3)
            {                
                SN = lines[2];
            }
            else
            {               
            }
            #endregion

            #region Read LS from file
            filePath = "license.ini";
            string LS = "";
            if (System.IO.File.Exists(filePath)) // // Error empty file
            { lines = File.ReadAllLines(filePath); };
           
            if (lines.Length >= 3)
            {
                LS = lines[2];
            }
            else
            {                
            }
            #endregion


            #region reduce LS to SNx  
            string SNx = GenerateSerialNumber(LS);
            #endregion

            
            return SNx == SN;
        }
    }


}




using System;
using System.Security.Cryptography;
using System.IO;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.ComponentModel;
using System.Data;
using System.Threading.Tasks;




namespace QuickMixCounter
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }
        

        //A_In: Array of Word; A_Out: Array of byte;
        //was
        //A, B, C, E:Array of byte;  //dAta FFot Mat  SWich
        //lenfile:integer;
        //i:integer;
        //j,n:integer;
        //U:cardinal;
        //d:byte ;
        //C0,C1,Count:integer;
        //FName:string;
        //tempS:string;
        
        public static byte ReadN(long Ui, byte L, byte[] B)
        {
            // procedure for reading a return number with length L bits
            // from array B[ ] from position Ui
            // Mandatory either dynamic array or index 0..n
            long i, k;
            byte ms; byte D;
            int wd;

            if (!(0 < L && L < 8)) { MessageBox.Show("Error: readN L is no range"); }; // exit if the data length is incorrect
            Ui--; // convert position to bit index
            k = Ui / 8; // calculate the byte index in the array
            i = Ui / 7; // number of shifts
                                     // get the most significant bits
            if ((i + L) > 8) { wd = B[k + 1] * 256; } else { wd = 0; };
            wd |= B[k]; // combine two bytes
            D = (byte)(wd >> (byte)i); // shift the number
                                           // forming a mask based on data length
            ms = 0;
            for (i = 1; i < (L + 1); i++) { ms = (byte)(ms + ms + 1); }
            return (byte)(D&ms); // masking extra bits
        }        
        public static void AppendN( byte D, byte L, int Ui, byte[] B )
        {
            // procedure for adding a number D of length L bits
            // into array "B" from position U bits
        int k=0; int i;
        byte ms=0;
        int wd;

        if (!(0 < L && L < 8))
            { MessageBox.Show("Error: readN L is no range"); } // exit if the data length is incorrect
        for (i = 1; i < (L + 1); i++) { ms = (byte)(ms + ms + 1); };

        D = (byte)(D&ms); // masking extra bits
        i= Ui & 7; // number of shifts
        wd = D;
            wd <<= i; // get shifted data
            Ui += L;
        k= ((Ui-1) / 8) + 1; // calculate the new length of the array
            Array.Resize<byte>(ref B, k + 1); // setting the length of the array, counting from 0!
            if (i + L > 8) {
                i = B.Length - 1;
                // adding a number to the array
                B[i] = (byte)(B[i] | (0xFF & ((byte)(wd >> 8))));
                B[i - 1] = (byte)(B[i - 1] | ((byte)(0xFF & (byte)wd)));
            } else
            {
                i = B.Length - 1;
                // adding a number to the array
                B[i] = (byte)(B[i] | (byte)(0xFF & (byte)(wd)));
            }
        }



        private void Button1_Click(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open as Data File"))) 
            using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save as Reduced Data File"))) 
            using (FileStream fs2 = File.OpenWrite(MCDE.SaveDialog("Save DNA Data File"))) 
            
            { 
            byte[] b = new byte[8];
            head A;
            byte c;
            int readLen;
            int i = 0;
            while ((readLen = fs.Read(b, 0, 8)) > 0)
                {
                A = System.BitConverter.ToUInt64(b, 0);
                    /*Here is a block of XOR and ROR64 */
                    ulong v = MCDE.TransposeBitMatrix(A);
                    /*Here is a block of XOR and ROR64 */
                    A = v;
                b = System.BitConverter.GetBytes(A);
                fs1.Write(b, 0, 7); // In one stream of information
                    c = b[7];
                fs2.WriteByte(c); // to another DNA stream
                }
            }
            MessageBox.Show("OK");
        }
        private void Button2_Click(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open as Reduced Data File")))
            using (FileStream fs1 = File.OpenRead(MCDE.OpenDialog("Open as DNA Data File")))
            using (FileStream fs2 = File.OpenWrite(MCDE.SaveDialog("Save as Data File")))
            {
                byte[] b = new byte[8];           
                head A;
                byte c;
                int readLen;             
                int i = 0;
                while ((readLen = fs.Read(b, 0, 7)) > 0) // read Reduced Data 7 bytes
                {
                    c = (byte)fs1.ReadByte();// read DNA Data 1 byte
                    b[7] = c;
                    A = System.BitConverter.ToUInt64(b, 0);
                    /*Here is a block of XOR and ROR64 */
                    ulong v = MCDE.TransposeBitMatrix(A);
                    /*Here is a block of XOR and ROR64 */
                    A = v;
                    b = System.BitConverter.GetBytes(A);
                    fs2.Write(b, 0, 8); // Recovered data
                    
                }
            }
            MessageBox.Show("OK");

        }

        private void Button3_Click(object sender, EventArgs e)
        {
            
            //uint w=Convert.ToUInt32(textBox1.Text);
            //w=MCDE.ROR32(w, 1);
            //textBox1.Text = Convert.ToString(w);


        }

        private void button10_Click(object sender, EventArgs e)
        {
            // Read file 1 as a sequence of matrices
            //string s1 = MCDE.OpenDialog();
            //string s2 = MCDE.SaveDialog();
            //string s3 = MCDE.SaveDialog();
//using (var reader = new BinaryReader(File.Open(s1, FileMode.Open)))
            {
                //Loop through each 8 bytes in the file 
                //for (int i = 0; i < reader.BaseStream.Length; i += 8)
                //{
                //    //Create an array to store the 8 bytes of a matrix 
                //    byte[] b = new byte[8];

                //    //Read the next 8 bytes from the file into the array  
                //    for (int j = 0; j < b.Length; j++)
                //        b[j] = reader.ReadByte();

                //    //Perform a transpose of each matrix  
                //    //TransposeMatrix(b);

                    



                //    //Save first 4 bytes of each matrix to file 2                     
                //    using (var writer2 = new BinaryWriter(File.Open(s2, FileMode.Append))) { writer2.Write(b, 0, 1); }

                //    //Save remaining 4 bytes of each matrix to file 3                 
                //    using (var writer3 = new BinaryWriter(File.Open(s3, FileMode.Append))) { writer3.Write(b, 1, 7); }
                //}
            }

            //Function to perform transpose on an 8x8 bit matrix stored in an array of bytes b[8]   private static void TransposeMatrix(byte[] b)  {      byte temp;           for (int i=0;i<4;i++)      {           int k=7-i;           temp=b[i];           b[i]=b[k];           b[k]=temp;       }}
        }

        private void button4_Click(object sender, EventArgs e)
        {
            string s = MCDE.OpenDialog("Open Data File");
            string s1 = MCDE.SaveDialog("Save Cript Data File");
            byte[] b = new byte[512];
            int i = 0;
            do
            { 
                b = MCDE.ReadBlockFromFile(s, i*512, 512);
                MCDE.MixByteArr512(b); // you can give 2 keys
                                  //MCDE.UnMixByteArr512(b);//you can give 2 keys
                MCDE.WriteBlockToFile(s1, b, i*512, 512);
                i++;
            }
            while (b.Length == 512);
            MessageBox.Show("OK");
        }

        private void button3_Click_1(object sender, EventArgs e)
        {

            string s = MCDE.OpenDialog("Open Data File");
            string s1 = MCDE.SaveDialog("Save Cript Data File");
            byte[] b = new byte[512];
            int i = 0;
            do
            {
                b = MCDE.ReadBlockFromFile(s, i * 512, 512);
                
                MCDE.MixByteArr512(b); // you can give 2 keys
                                      //MCDE.UnMixByteArr512(b);//you can give 2 keys
                MCDE.WriteBlockToFile(s1, b, i * 512, 512);
                i++;
            }
            while (b.Length == 512);
            MessageBox.Show("OK");

        }

        private void button11_Click(object sender, EventArgs e)
        {
            
        }

        private void button12_Click(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open    File")))

            using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save   File")))
            {
                byte[] b = new byte[1];
                head A;
                byte c;
                int readLen;
                int i = 0;
                while ((readLen = fs.Read(b, 0, 1)) > 0) // read Reduced Data 7 bytes
                {
                    b[0] ^= (byte)(MCDE.RndConst(314159265, 9874, 3));
                    fs1.Write(b, 0, 1); // Recovered data

                }
            }
            MessageBox.Show("OK");
        }

        private void button11_Click_1(object sender, EventArgs e)
        {
            using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open    File")))

            using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save   File")))
            {
                byte[] b = new byte[1];
                head A;
                byte c;
                int readLen;
                int i = 0;
                while ((readLen = fs.Read(b, 0, 1)) > 0) // read Reduced Data 7 bytes
                {
                    i--;
                    b[0] ^= (byte)(MCDE.RndConst((uint)(314159265 + b[0]+i), (uint)(9874+i), 3));
                    fs1.Write(b, 0, 1); // Recovered data

                }
            }
            MessageBox.Show("OK");
            
        }
    }
    
}

// Array.Reverse(people, 1, 3);
//uint[] uints = new uint[Mb.Length];
//string s = Convert.ToString(Fost);
//MessageBox.Show(s);


This ID

[IDNumber]
ID=
9VqoBnch5ZWWXsNhn6T4R60vWZtqEDD7JF6cXM1W4V1gPs12ZTwRh3Ww3xr2Pc36bMzRiO0pnOjspwfXDPR40adfoCH0AtaDFFSfpfaqsTNFWSahSKwNs0ackbfv6lo6XaiWsiT2BzaZnOS7BI227B2s7NhDi6ZfT3f5Uwl0ZDDAHYj1aXiQzEn5cPRkgno2fIu2Jv66RVQf5cDz6EUMWRjxskP7RWSO5DgEzo1xFRDhhZJI6YTHZvQegDcTiijJs1O2g0iB05CMEf2FDcgDo5pNEk9HKyJc6v0VYgx1316SOWlfF6FE7XFXP6XrHnWf6cvRWRf7jRLlNSyoyYFiVKDme2P1iMFjRBFD0LDCVHEec6558WTjuJ23NiCOnI6L2nMc7XkhTW0oDViAqXiBYMSOqWdDoEYQBjOjFZX10geLaq1SNwMfkoXpvfWS4fQ7


License no

[LicenseNumber]
License=
oSfPlTe0ntHc4HsMhfSxUHS1wh5xPv20Rl8ZFltp5jMKWyc4RM1mMl29IMAlKDZMxU13EMDmLWEPjILUc0E3Ertx8RmZifUbfxDUzyu2r8iXQwqMfcSFw00jbyT25OnSfDuQ3WoBGieWMaKRZVRO5mlM12qSv4e6W0SJWZrdOiMSFDgk24YfiYq0k2GEBbk8QBGZjMYf64d1hu2gVDTZ0ZBlLc20zbUUfyzhyjERsCaFPFiFriZE8O6UnPwivBZmPZrAeTDMlwqQ07EVH0bRDoilznFaxFr1DZu4BBIUFmL6LZHO3na3jyaWE5Naj1isrhBIFR8En2tOEiMf9yhhfycyE4RZgRcZpQ7TgKyUvWSCOKYsPlWWnxd5fKv0ZKHu0PTjjUgEQOkoPLJIGT1leYqyGLosv2DQgDvcpHbcrs2I4JhjAsbZ3kLaLTHt0OxC2JFDhkPQ2DgYhMghTd0qOjWI5isfgFmB7OeF4TEoyTWpHF1r5Pz2bV2pbgDctGLC6txBcVsuMf513PUMOEBJHFUXrHW7eLbigXpFXffKLinFiL93fZOZfsntESyjxQrSihn2p7SeZ8ZznaF52sFIto2jkOPQc9a912vwJFKMUijLWsi2oVWHAZTJ2ieGQobNOFP73Tma5cexZCOt1Gljce7pgFMgjoyWg4ajSKFUZ9MWD5g3aZWpEchmaWyfs9Jl5pMd9l2fRfyWM2jZMDIcm6reCUILebq6oxXKBRIB9jDtNQ7BEyjjrH6pjx37WT7j3BHkZx4LAj3Pl0DLNxr7aHqYgK4PehW6mvemiSYM8fOPU1ADlWpzbKEuNDEhXF1ragxA0eM0yiRHHaQrBsE7iirx1pLDnMFuBkRx5DDOISreUmlyg0c40fI8v1aC61Eje4oLLoWTEklBMHcSQazV2pOeYlFyBaj4FLWe2KRh5meDBpJyjA255z5VMqDZCaDHfcZBpZBPuNlYhScGSkdPCDxTstMeF



Serial no

[SerialNumber]
Serial=
52W6rTiC0VhsggOBKqCW65nxfMFL7OVTnF22aADHQiOBMiRziyXGxrWklM2ZH6YFk3PFQWvOfsmKj2BHzFBpHiIaxvwffTej13sncpFTFTb0SwQc4f0Uhx8W6jZnCL2OkGLIkcrijzRLxz8jWDPs3tH0r32BUrnQEyFCZPiBbUfDvec7F74TvHDFiCX0T23vxdgBUp2ZILhgb677ilj1cMBmhFXm1h1E7EUDyfVEYnLTLaS6aST2hr6Y3FZulkxpMfWyBhfy

Redtxt

Version 0
User 0

Package contents:
NaVeOl_ECO.exe
id.ini
serial.ini
license.ini



Relate it
[IDNumber]
ID=
EZNu6aE5XKETr5IGocahSm3xGR9WEGTHxdWEuGiROxu9kKuKHo4VHrf1rCFmCKROWKVp3mvVLKjY54bXSKm2Wa3R0YoE50Ow63vcT7FNKiI6QqZNjBSDWWhOXWMTYdTvXavHNY6mYVnt6jU3T0bFAE0HXWxVxttbdaMIcTnITcTobcV2sbSat8trpN5knevFSXq8vTOmaLJLd6VyzIHbsbNCcFKx1P52QrkZeIcBSpEzGsv6OUEpSTuvo03eVgaukiOFzZinqzJga5dfbSnYainSoMFTAICOwfeIKO5iOeatIYwZ6xaCOVmGSdXhmdc3mVRaIbbfVpnwDtm39nUxXWcSPVCFSTZW1xvERghYX4ZvAXizvHQgov2bBGTTL6jbPRSeErwHIkYjUw0YQWdEMfWOJIAEjNc8xOxJg5bKnYQgOVCBxTzjQvWV4jPHOga6


Relaese this
[LicenseNumber]
License=
cvSKPtDI4QxoXFgPfeUyqPIVvXI6rKS5igwjSD0tvFAab2yLkf7YAxGEgLaxEOKkHwVaFlD8oiFxTHTqwBkWh52sVioM6QgCSHnqAZaJvpqRh9ZCWBnq3T0F6vo9cCFQPcS4fE2xin1SiVc4LcpjIzcpKLFv8kzjig0uVOJwRqk0OaNCytYenLtvrpYhIbDweTCMOLgu08qv43jkXy5Y4wHx0aZ6zjgw5NVYXYmkzYPBKv9BDqj6Uh0gKyOntW8Mnw5g55eRgOgfvXLWcA64RGig2Fr76m1Kmx16jT0SNLuGSHzkLdP3qZ8YEkhRBelyd5xuqppIKplR1IA7DsQXiZ3eqRk84rfhx4aoRvZjmbZhRGYcKTW3J1ivdfwr5vp1PeEo8u26FjCRSYC0gt7PaVgmoYGRhyrmYkffZ2kbgXGYX0XIzAjYG4KxT4Hcrx64j0hA4Fj46kaL543mwgDtRqVYk6AVkvWrdSDBtimBhFNYLjZscjLOFgwkkNQ6zUKnazLba1vaAsPZZuSzS6bkFXuhZMr7oTFQYG3qEQla06donSDyZjS2dcXRAN2rIi5fiUXaba0ERYwFfjBARBQxrpjSjRSObVViVkm9YooLEiFtcUqk2vb2nK4CpJpB4bjzxQ3gfSYa5OVhY43RVycrhaJWNER455VhL8asQvacw0LheDOGesE3FFXozSwi60ugW3xI01HsiuMAKiXYKVHHzn5pudx05bFwszYomX0hDsVRohgImZ88JmnXBLyqWnI9GePTsIQJX4fxKgDkhZFYeKrLNjQy6gcaMEKW2PyKUeSEuVekKOkBOY41SVL5fheqVYyJLikJZQiPnz2DJ3mt26jIpxTQj7qRxTkhA9exlUsDcp0eYgfeP7aBmjCcwjztp8GfTRHLHSjTLFwfVtgWHkCzTmgVWII0B0YI6mkUt26Mr4CsFXpPkVtXMdrRIByqdRE3LKNrUoc6aQ1T4juXBy6tC8C1v

Relaeseserail
[SerialNumber]
Serial=
V7cv2jvYzjGWDnzvndJkYkQtGjU2ch6cAZiNWr4XB8TOPq0wg79WO6QTD6GR7HgavX0SIKkQImbWXAXInOhdGQao0gZTY5RKvVuOY0pVawQ6cnWT0XPmq6g5gYPcvdBONv3eOb6kdeirU6gTezFQ9NCRmejohTI9WtoadkhMSCRE3hjVojAt3xOatza6VfpheqbZIAYdajAkSWdnrVmEgwDoYSzqQpajSBXLSHj8GP6wZxUkoUQjqIem2xwnYhOe5npqckqZ


Absolute

C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\bin\Debug\NaVeOl_Cripto.exe.config
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\bin\Debug\NaVeOl_Cripto.exe
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\bin\Debug\NaVeOl_Cripto.pdb
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.exe
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.pdb
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\bin\Debug\NaVeOl_Cripto.exe.config
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\bin\Debug\NaVeOl_Cripto.exe
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\bin\Debug\NaVeOl_Cripto.pdb
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.exe
C:\MS_Visual_Studio_Projects\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.pdb
C:\Users\Alpha_nl\Documents\Proba_MS_Visual_Studio\NaVeOl_Cripto\obj\Debug\NaVeOl_Cripto.FormConfig.resources
C:\BelgianNaVeOl_Cript\NaVeOl_Cripto160623\bin\Debug\NaVeOl_Cripto.exe.config
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\bin\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\bin\Debug\NaVeOl_Cripto.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.FormConfig.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto160623\obj\Debug\NaVeOl_Cripto.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\bin\Debug\NaVeOl_Cripto.exe.config
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\bin\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\bin\Debug\NaVeOl_Cripto.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.FormConfig.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto280623\obj\Debug\NaVeOl_Cripto.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.FormConfig.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\obj\Debug\NaVeOl_Cripto.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\bin\Debug\NaVeOl_Cripto.exe.config
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\bin\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto090723\bin\Debug\NaVeOl_Cripto.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.FormConfig.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\bin\Debug\NaVeOl_Cripto.exe.config
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\bin\Debug\NaVeOl_Cripto.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_Cripto1407230\bin\Debug\NaVeOl_Cripto.pdb
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.Form1.resources
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.FormConfig.resources
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.Resource1.resources
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\bin\Debug\NaVeOl_ECO.exe.config
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\bin\Debug\NaVeOl_ECO.exe
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\bin\Debug\NaVeOl_ECO.pdb
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_ECO.exe
F:\John.Fox\Programming\NaVeOl\NaVeOl_Cripto1407230\obj\Debug\NaVeOl_ECO.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\bin\Debug\NaVeOl_ECO.exe.config
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\bin\Debug\NaVeOl_ECO.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\bin\Debug\NaVeOl_ECO.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_Cripto.FormConfig.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_ECO.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_160823_slow\obj\Debug\NaVeOl_ECO.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\bin\Debug\NaVeOl_ECO.exe.config
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\bin\Debug\NaVeOl_ECO.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\bin\Debug\NaVeOl_ECO.pdb
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.Form1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.FormConfig.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.Resource1.resources
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_ECO.exe
C:\Belgian\NaVeOl_Cript\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_ECO.pdb
G:\NaVeOl_ECO_26092023\bin\Debug\NaVeOl_ECO.exe.config
G:\NaVeOl_ECO_26092023\bin\Debug\NaVeOl_ECO.exe
G:\NaVeOl_ECO_26092023\bin\Debug\NaVeOl_ECO.pdb
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.Form1.resources
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.FormConfig.resources
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.Resource1.resources
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_ECO.exe
G:\NaVeOl_ECO_26092023\obj\Debug\NaVeOl_ECO.pdb
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.csproj.SuggestedBindingRedirects.cache
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.Form1.resources
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.FormConfig.resources
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.Resource1.resources
G:\NaVeOl_Cript Page 02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_ECO.exe
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\obj\Debug\NaVeOl_ECO.pdb
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\bin\Debug\NaVeOl_ECO.exe.config
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\bin\Debug\NaVeOl_ECO.exe
G:\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Professional_v2\bin\Debug\NaVeOl_ECO.pdb
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\bin\Debug\NaVeOl_ECO.exe.config
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\bin\Debug\NaVeOl_ECO.exe
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\bin\Debug\NaVeOl_ECO.pdb
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_Cripto.csproj.AssemblyReference.cache
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_Cripto.Form1.resources
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_Cripto.FormConfig.resources
F:\Belgium\NaVeOl_Cript\NaVeOl_Cript Selection 02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_Cripto.Properties.Resources.resources
F:\Belgium\NaVeOl_Cript\NaVeOl_Cript Selection 02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_Cripto.Resource1.resources
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_Cripto.csproj.GenerateResource.cache
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_Cripto.csproj.CoreCompileInputs.cache
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_ECO.exe
F:\Belgian\NaVeOl_Cript\NaVeOl_Cript Selection02102023\NaVeOl_ECO_Git\obj\Debug\NaVeOl_ECO.pdb
